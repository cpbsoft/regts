---
title: "Introduction to package regts"
author: "Rob van Harrevelt and Anita van der Roest"
date: '`r Sys.Date()`'
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
linkcolor: blue    
---
<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{Introduction package regts}
-->

\newcommand{\longerpage}[1][1]{\enlargethispage{#1\baselineskip}}
\newcommand{\shorterpage}[1][1]{\enlargethispage{-#1\baselineskip}}
%
\newcommand{\needlines}[1]{\Needspace{#1\baselineskip}}

```{r echo = FALSE, message = FALSE}
library(regts)
library(Hmisc)
#library(xlsx)
data <- matrix(c(3,2,4,3,5,2,5,3), ncol = 2)
data1 <- matrix(c(1,3,2,6,4,8,3,0,9), ncol = 3)

# input/output chunks are separated
# R inputlines start with >, outputlines with nothing
knitr::opts_chunk$set(collapse = FALSE, comment = "", prompt = TRUE)

```
\longerpage[1]

\newpage

# Introduction

When you start looking in R for timeseries you easily find several 
classes and packages, class `ts` from the `stats` package and `zoo` being mentioned 
most.

The function `ts` creates a regular timeseries object with class `ts`. This can 
be a univariate or multivariate object. It has a start, an end, a frequency and 
you can print, plot, extend and update it. But class `ts` has no easy way to deal 
with fixed periods. 

`Regts` is a package defined for regular timeseries objects built on class `ts`, 
but with features for easier selecting periods. The `regts` package defines a 
class `regts` that is an extension to the `ts` class.
Because of this the `regts` class benefits of all the functionality of `ts`.
The period handling is much easier than in the `ts` class, particularly for 
monthly, quarterly and annual timeseries.

Package `xts` also facilitates period selection, but concentrates more on daily 
(or weekly) based data. 
 
Package `regts` provides some more extensions to package `ts`: 

* the use of labels, a description of the timeseries
* an easy way to convert a data frame to a timeseries object
* a function to calculate differences between multiple timeseries
* and furthermore a special set of aggregation functions for timeseries 
representing growth rates

To use this package `regts` load it with:
```{r eval = FALSE}
library(regts)
```


# Creation `regts`

## Single timeseries
A single `regts` timeseries is created with the function `regts`. An example for 
a quarterly timeseries:

```{r echo = 1}
tq <- regts(1:10, start = "2016Q3")
tq
```
The end period of the timeseries is based on the length of the input data.
The period can also be a month, like `"2016M3"`, or a year: 

```{r echo = 1}
ty <- regts(c(.11, .29, .18, .24), start = "2017")
ty
```
Note that annual timeseries are printed differently than quarterly timeseries.

The `class` of `tq` and `ty` is `regts`, and because of the inheritance, also `ts`.
```{r}
class(tq)
```

If the input data is longer than you require you can make a selection with the 
`end` argument:

```{r}
ts_data <- regts(1:10, start = "2016Q1", end = "2016Q4")
```
If the input data is shorter than the period determined by the `start` and the 
`end` argument, the data is repeated:

```{r}
ts_data <- regts(1:2, start = "2016Q1", end = "2017Q1")
ts_data
```
As you can see the length of the period doesn't have to be a multiple of the 
length of the input data.

Class `regts` recognizes special formats for quarterly (`2016Q1`) and monthly 
(`2016M1`) timeseries.
To create timeseries with a different frequency, specify the frequency argument:

```{r}
ts_data <- regts(1:10, start = "2016-1", end = "2017-1", frequency = 2)
```

Instead of arguments `start` and `end` you can also specify argument `period`:
```{r}
ts_data <- regts(1:10, period = "2016Q1/2016Q4")
```
Input for this period may be a character string as shown above, but also a 
variable of type  `regperiod_range`. This type will be explained in section \ref{sec:regperiod}.

## Multivariate timeseries \label{multits}
Sometimes it is more convenient to combine several timeseries with the same 
period in a single object: a multivariate timeseries. 
A multivariate timeseries is just a matrix with two or more columns.
multivariate `regts` is such a matrix with some extra attributes. 

```{r}
rts <- regts(matrix(1:9, ncol = 3), start = "2016Q1", names = c("a", "b", "c"))
rts
```
Argument `names` can be used to set the column names. If omitted then the 
column names of the input matrix are used. In the next example the input 
matrix has no column names:

```{r}
rts1 <- regts(matrix(1:9, ncol = 3), start = "2016Q1")
rts1
```

A multivariate timeseries inherits the classes `mts` (multivariate `ts`), 
`ts` and `matrix`:

```{r}
class(rts)
```

Timeseries names are preferably valid R names (only include a-z, A-Z, _, 
and 0-9 and start with a letter) and well chosen. In general they will be brief. 
If more documentation is needed for a timeseries than just this (short) name, 
optionally labels can be added
(see also section [labels](#labels)).


### Column selection and creation

Column selection for regts is the same as for matrices. 

```{r}
a1_ts <- rts[ , "a"]
a1_ts
ac_ts <- rts[ , c("a", "c")]
ac_ts
```
`a1_ts` is now a univariate timeseries, `ac_ts` a multivariate subset of `rts`. 

For the `regts` class we can also create new columns:

```{r}
rts[, "x"] <- 2 * rts[, "a"]  # creating a new column "x"
rts
```

This is not possible for classes `ts` and `matrix`.


### Selecting columns with a regular expression
The `regts` package contains a function `select_columns` to select columns of 
an R object with column names. Besides `regts` this can be a `matrix` or a 
`data frame`. The columns with names matching a given regular expression are 
selected. A few examples:

```{r}
rts <- regts(matrix(1:8, ncol = 4), start = "2016Q1", names = c("a1", "b1", "a2", "b2"))
select_columns(rts, regex = "a.*")  # all columns with names starting with "a"
select_columns(rts, regex = ".+1")  # all columns with names ending with 1
```

The syntax of `regular expression` patterns is described in the R Documentation.


## Matrices with one column
If a `regts` is created from a matrix with only one column, the timeseries is 
single (or univariate). So there are two types of single timeseries: one that 
is based on a vector and one that is based on a one-column matrix: 

```{r}
ts      <- regts(1:8, start = "2016Q1")
ts_1col <- regts(matrix(1:8, ncol = 1), start = "2016Q1")
```
They have identical output:
```{r}
ts
ts_1col
```
and identical classes:

```{r}
class(ts)
class(ts_1col)
```

but different underlying data.

Another difference between the 'vector' version and the 'matrix-1-column' 
version is that the latter can have a column name:

```{r}
ts_1col <- regts(matrix(1:8, ncol = 1), start = "2016Q1", names = "a")
```
The column name is not printed with the output, but can be shown with the 
`View` or the `colnames` function:

```{r}
colnames(ts_1col)
```

Single 'vector' timeseries never have a column name.

A single 'matrix-1-column' timeseries is also created when a single column 
is selected from a multivariate timeseries with the argument `drop = FALSE`. 
In this case the column name is preserved. If this argument is omitted 
(or `drop = TRUE` is used) a single 'vector' timeseries is created. A possible 
column name disapppears in this case. An example:  

```{r results = "hide"}
rts <- regts(matrix(1:8, ncol = 2), start = "2016Q1", names = c("a", "b"))

rts[ ,1, drop = FALSE] # result is a one-dimensional matrix with column name "a"
rts[ ,2]               # result is a vector, column name "b" is lost
```

\newpage
# Period selection \label{sec:periodselection}

The package `regts` is specially designed for the selection of periods. Where 
for a `ts` timeseries you have to use the `window` function:

```{r}
ts <- ts(c(1,2,3,4,5,6,7,8), start=c(2016,1), end=c(2017,4), freq=4)
window(ts, start = c(2016,4), end = c(2017,2))
```

with a `regts` you can select periods with the selection operator `[]`. Period 
selection is a form of subsetting. 

```{r results = "hide"}
ts <- regts(1:8, start = "2016Q1", end = "2017Q4")
ts["2016Q4/2017Q2"]
```
Besides a range you can also select one period:

```{r results = "hide"}
ts["2017Q1"]
```    
    
or a range with an open beginning or end:

```{r results = "hide"}
ts["/2017Q2"]
ts["2017Q1/"]
```
or a range with a lower frequency:

```{r}
ts["2017"]
```

If a selection is specified outside the defined range, the timeseries is filled 
with NA values for that range:

```{r}
ts["/2018Q2"]
ts["2015Q3/"] 
```

Period selection can also be applied on the left hand side of an assignment, in 
the target timeseries. The object must exist before applying selection.

```{r}
rts1 <- regts(1:8, start = "2010Q1", end = "2011Q4")
rts1["2011Q2"] <- 2
rts1["/2010Q3"] <- 99
rts1
```
\newpage
The period of the timeseries can also be extended:
```{r}
rts1["2009Q1/2009Q2"] <- rts1["2010Q3/2010Q4"]
rts1
```
The missing quarters (`2009Q3` and `2009Q4`) are filled in with NA values.

## Period selection for multivariate regts

Selecting a period for a multivariate regts is quite similar. You can select 
one or more periods, or a combination of period(s) and columns:

```{r}
rts <- regts(matrix(1:12, ncol = 3), start = "2011Q1", names = c("a", "b", "c"))
rts["2011Q2", ]

rts["2011Q2"]                 # the , is not necessary

rts["2011Q1/2012Q2", "c"]     # extended selection
```

All the extended elements become NA.

Select a combination of period and columns:

```{r}
rts["2011Q4/", c("a", "b")]
```

Selection can also take place in the target timeseries:

```{r echo = 1:3}
rts[, "x"] <- NA              # define an extra column
rts["2012Q1", ] <- 99         # extend period for all columns 
rts["2011", "x"] <- 1         # update all quarters in 2011 in column "x"
rts
```

# `regperiod` and `regperiod_range`\label{sec:regperiod}

When the same period is used several times, it is preferable to define a variable containing this period. Package `regts` defines special classes representing 
periods: the `regperiod` class for a single period and the `regperiod_range` 
class for a range of periods.

## `regperiod`

A `regperiod` object can be created with the `regperiod` function. 

```{r}
prd1 <- regperiod("2016Q4")
prd1
prd2 <- regperiod("2015-2", frequency = 4)
prd2
```

In the second example the `frequency` has to be specified. `"2015-2"` is 
ambiguous. Here "2" denotes the second quarter but it could also be for instance 
a month indicator or a half year. The `frequency` argument is required if you 
want to define a period with a frequency other than 1, 4 or 12, since there is 
no special format for these frequencies.

`regperiod` objects can be used as input for the `start` and `end` arguments of 
the `regts` function.

```{r eval = TRUE}
ts    <- regts(1:10, start = prd1)
```

When printed a `regperiod` variable seems to be nothing more than a character 
string. With the `str` function we can show the internal representation of a 
`regperiod` object:

```{r}
str(regperiod("2016Q4"))
```

The internal representation of period `2016Q4` is the number of quarters since 
the beginning of the Christian era, starting with 0 (`8067 = 2016 * 4 + 3`).

## `regperiod_range`
There is also a `regperiod_range`, an object that represents an interval of 
periods. Such a range can be created in the following ways:

```{r}
range <- regperiod_range("2014Q4", "2017Q4")
range
regperiod_range("2014Q4/2017Q4")
```

The lower or upper bound of the range may also be undetermined:

```{r}
regperiod_range("2017Q1", NULL)      # No upper bound
```

A `regperiod_range` variable can be used in the `regts` function, specifying the 
`period` argument:
 
```{r}
range1 <- regperiod_range("2016Q1", "2016Q3")
rts <- regts(matrix(1:18, ncol = 3), period = range1, names = c("a", "b", "c"))
rts
```
The length of a range may be obtained by using the `length_range` function:

```{r}
length_range(range1)
```
Functions `start_period` and `end_period` are used to retrieve the first and 
last period in a `regperiod_range`:

```{r}
start_period(range1)
end_period(range1)
range2 <- regperiod_range(start_period(range1)+1, end_period(range1)-1)
ts <- regts(data, period = range2)
```

## Shifting period(s)
With operators `+` and `-` the period can be shifted. Some examples for `regperiod`: 

```{r}
regperiod("2016Q4") + 1
p1 <- regperiod("2015Q1")
p1-5
```

And for a `regperiod_range`:

```{r}
regperiod_range("2016Q4", "2017Q4") + 1
regperiod_range(p1, p1+4)            # a `regperiod` as input
```

Note that one of the operands must be numeric^[Command `regperiod("2015Q1") + regperiod("2015Q2")` results in an error message: 'Arithmetic operation on two 
regperiods is not allowed.'].


## Selecting and updating
In section \ref{sec:periodselection} we have shown how periods can be selected 
with a string. A `regperiod` can also be used to select or update a period of a 
timeseries object.  Consider the following (previously defined) timeseries:

```{r}
rts
```
Use a `regperiod` to select and update the timeseries.
```{r}
prd1 <- regperiod("2016Q2")
rts[prd1] 
rts[prd1] <- 3
rts
```

A `regperiod_range` can be used to select and update multiple periods:

```{r}
# define a period and make selections
range <- regperiod_range("2016Q2", "2016Q3")
var <- rts[range]     
rts[range, c("a", "b")]
# define another period and create a new timeseries column
smpl <- regperiod_range("2016Q1", "2017Q1")
rts[smpl, "xx"] <- 2                
rts
```

Note that because timeseries `xx` is created with an extended period, all 
timeseries in (multivariate regts) object `rts` are extended.

\newpage
# Conversion between `data frame` and `regts` \label{dataframe}

It is possible to use a (part of a) data frame as input data for a `regts`

```{r}
df  <- data.frame(a = 1:3, b = 4:6, c = 7:9)
ts <- regts(df, start = "2017Q1")             # create a multivariate regts
ts
```

The function `regts` uses the `data.matrix` function in the `base` package to 
convert a data frame to a numeric matrix. By default the column names of the 
data frame are used for the timeseries names.

As with matrix input, it is also possible to specify names or add labels. This 
is already described in section \ref{multits}. Labeling is discussed in section \ref{labels}.

In the previous example we had to specify the period of the result timeseries.
Sometimes the period is already contained in the data frame, e.g. in the 
row names. Consider the following data frame:

```{r}
# data frame with period in row names
df <- data.frame(a = 1:3, b = 4:6)
rownames(df) <- c("2015Q3", "2015Q4", "2016Q1")
df
```

The function `as.regts` can be used to convert a `data.frame` to a `regts`:

```{r}
ts <- as.regts(df)
ts
```

Function `as.regts` assumes that the period is stored in the row names.
If the periods are in a column of the data frame, then the `time_column` argument 
can be used. You can specify the column name or number of the data frame in which 
the period is stored. Specifying 0 means the period is contained in the row names 
of the data frame.

```{r}
# data frame with period in column 'periods'
df2 <- data.frame(periods = c("2015Q3", "2015Q4", "2016Q1"), a = 1:3, b = 4:6)
ts2 <- as.regts(df2, time_column = "periods")
ts2
```

Function `as.regts` uses the function `regperiod` to convert the 'period text' 
(like `2015Q3`) to a `regperiod`.
This function can handle several period formats: `2016`, `2016Q4`, `2016.4q`,
`2016/4Q`, `2016-4q`, `2016_q4`, ...
where no distinction is made between 'q' and 'Q'.

If the period is ambiguous, use the frequency argument:
```{r}
# data frame with indicisive period in row names
df <- data.frame(a = 1:3, b = 4:6)
rownames(df) <- c("2015-3", "2015-4", "2016-1")
ts <- as.regts(df, frequency = 4)
```

If the data frame contains periods in another, non standard, format, it is 
possible to specify your own function for the conversion of a text to a 
`regperiod`. Use the `fun` argument, if necessary with extra arguments.

The reverse conversion from a `regts` to a `data frame` can be achieved with 
function `as.data.frame`. Therefore the `as.data.frame` function has been 
extended for `regts` types:

```{r}
as.data.frame(ts)
```

The results look similar to `ts`. The timeseries names have become the data frame 
column names and the periods show up in the row names. Of course the `classes` 
are different.


# Reading and writing timeseries 

Some common used file types to store data in R are Rdata, csv or xls(x) files.
Inside R projects, preferably use Rdata files. Writing and reading R objects to 
and from Rdata files is easy and efficient.
If data has to be exported, you can use for example csv or Excel files.

## `.Rdata` file
The `.Rdata` file, an R-readable binary file, is the most flexible type, multiple 
objects can be stored. It is also possible to store the entire workspace.

Data can be stored by the `save` function in the `base` package.

```{r}
save(df, file = "output.Rdata")
```

Data saved in an `.Rdata` file can be reloaded  by the `load` function. By default 
they are loaded in the workspace. 
All objects in the file are loaded. If you don't specify a path the current 
working directory is used. 

```{r}
load("output.Rdata")
```
Note that existing objects with the same name are replaced.

## External files

Functions for reading a csv or Excel file, typically return a `data frame`. 
This type can easily be converted to a `regts`, as explained in section \ref{dataframe}.
When storing a `regts` it is convenient to use a `data frame` as intermediate. 
This way the period is also written to file (`write.csv(ts)` ignores the period 
of the timeseries).

### Reading csv files
The most convenient way to read a csv file, is to use the `read.csv` function or 
another variant of the `read.table` function from the `utils` package (installed 
by default). For large files, the function `fread` from package `data.table` is 
suitable, because it is more efficient. 

Consider the following csv file 

```{r echo = FALSE, comment=""}
cat(readLines("test.csv"), sep = "\n")
```

Note that quarter `2010Q4` is missing in the file.

When reading information from this `csv file` with function `read.csv` , use `stringsAsFactors = FALSE` to prevent that character data (such as variable names) 
is converted to factors. The result of this function is a `data frame`:

```{r}
df <- read.csv("test.csv", stringsAsFactors = FALSE)
df
```

Convert this data frame with the `as.regts` function.
Since the period is to be found in the first column, we employ the `time_column` 
argument.

```{r}
series <- as.regts(df, time_column = 1)
series
```

Since `regts` (&aacute;nd `ts`) objects always have a continuous period^[`regts` 
and `ts` objects are regular timeseries. Packages `xts` and `zoo` provide also 
irregularly spaced timeseries objects. Then periods can be missing.], the missing 
quarters are filled with NA values. The `as.regts` function takes care of that. 

Sometimes the csv file is transposed, as in the following example:

```{r echo = FALSE, comment=""}
cat(readLines("transpose.csv"), sep = "\n")
```

Now the periods are in the first row (column headers), the next rows contain the timeseries. Since the periods are no valid names (valid names should start with 
[a-z]), we use argument `check.names = FALSE`, to prevent that the column names 
are prefixed with `X`.

```{r, echo = -3}
dft <- read.csv("transpose.csv", check.names = FALSE)
```

To convert this `data frame` to a `regts`, we first have to transpose it, since 
function `as.regts` assumes that the timeseries are stored columnwise in the 
data frame. Package `regts` contains a convenience function `transpose_df` for 
transposing a data frame.
With the `colname_column` argument it is possible to give the name or index of 
the column that will be used as column names. By default the `row names` of the 
original data frame are used. 

```{r, echo = 1:2}
df <- transpose_df(dft, colname_column = 1)
df
```

Then the dataframe can be converted to a `regts` as usual.
```{r}
ts <- as.regts(df)
```

The file may be more complicated then the example shown above. Possibly there 
are comments, extra rows or columns, or redundant information in the file. In 
that case the data frame read must be converted to a standard format with the 
variable names in the column names and the period in the row names. Use (negative) selection of rows and/or columns to get rid of unwanted information and the 
function `transpose_df` in case of a transposed file. The result should look 
something like the data frame printed above. This standardized data frame can 
easily be converted to a regts.

### Writing csv files
The best way to store `regts` timeseries in a csv file is to first convert the 
data to a `data frame` using the `as.data.frame` function. The period and names 
of the `regts` automatically become the `rownames` and `colnames` of the 
`data frame`.
By doing so the period of the timeseries is also written to file.

```{r}
rts <- regts(data, start = "2016Q1", names = c("a","b"))
df <- as.data.frame(rts)
df
write.csv(df, "result.csv")
```

You may want to write the data in transposed form:

```{r}
dft <- transpose_df(df)
dft
write.csv(dft, "result_transposed.csv")
```


### Reading and writing Excel files
As explained in the subsections above, we use a data frame as an intermediate 
object for reading and writing timeseries from and to csv files. The same 
approach can be used for reading and writing Excel files.

There are several packages available for reading and writing Excel files: e.g. 
`readxl` for reading, `WriteXLS` for writing and `xlsx` and `openxlsx` or 
`XLConnect` for both, see the CRAN documentation. 

git@gitlab.cpb.nl:rvh/tijdreeksen-R.gi
# Operators and functions for `regts`
Since the `regts` class is an extension of the `ts` class all functionality 
from this class is available.
All arithmetic (`+`, `-`, `*`, `/`, `^`, `%%`, `%/%`), logical (`&&`, `||`, `!`), relational (`==`, `!=`, `<`, `<=`, `>`, `>=`) and subsetting (`[]`) operators 
applicable for a `ts` variable, can be used for a `regts` timeseries. 
Some examples:

```{r}
tx <- regts(1:10, start = "2017Q1")

# operators
ty    <- 2*tx + 1
tpyth <- tx^2 + ty^2   
modulo <- tx %% 2
tlog  <- tx < ty && ty > 1
number <- tx["2017Q2"]

```
When a binary arithmetic operator is used on two timeseries objects, the 
intersection of the periods is taken:

```{r}
tx <- regts(1:6, start = "2016Q1")
ty <- regts(1:6, start = "2017Q1")
tx + ty
```

You can use all functions applicable to a `ts` class timeseries. Some examples:
```{r, eval = FALSE}
tsin <- sin(tx)
tlog <- log(tx)
diff(tx)
plot(tx)
```


## Combining timeseries
As we have seen all functions that are available for `ts` are also available 
for `regts`. The `cbind` function (an S3 generic function) is one of them: it 
binds two or more objects with a common frequency. With the `cbind` function 
it is easy to combine several univariate timeseries to a multivariate timeseries, 
or a combination of univariate and multivariate timeseries to a new multivariate timeseries. 

Yet the extension for `regts` has special features: arguments `union` and `suffixes`. 

The argument `union` effects the period range. With `union = TRUE`, the default 
value, the union of the period ranges of the joined objects is taken, otherwise 
it is the `intersection`. An example:

```{r}
rt1 <- regts(1:4, start = "2016Q1")
rt2 <- regts(1:4, start = "2016Q2")
```
\newpage
```{r}
cbind(rt1, rt2, union = TRUE)
cbind(rt1, rt2, union = FALSE)
```
For `union = TRUE` the result is padded with NA's if needed.

```{r echo = FALSE, results = "hide"}
data <- matrix(1:8, ncol = 2)
rt1 <- regts(data, start = "2016", names = c("a", "b"))
rt2 <- regts(data, start = "2016", names = c("d", "c"))
t1  <- ts(data, start = c(2016), names = c("a", "b"))
t2  <- ts(data, start = c(2016), names = c("d", "c"))

cbind(rt1,rt2)
ts.union(t1, t2)
cbind(t1,t2)

```

The `suffixes` argument is obligatory if the joined objects have overlapping 
column names:

```{r}
rt1 <- regts(data1, start = "2016Q1", names = c("b", "a", "c"))
rt2 <- regts(data, start = "2016Q1", names = c("d", "b"))

cbind(rt1, rt2, suffixes = c("_1","_2"))
```

The implementation of `cbind.regts` is also different from function `cbind.ts` 
(which is an alias for `ts.union`) because of the fact that available column 
names are always preserved.


# Multiple or chain calculations
Sometimes you have a 'chain' of calculations, where the left hand side of an 
equation is used in the right hand side of a following equation. For example:

```{r}
a <- regts(1:4, start = "2010Q2")
b <- a + 1
c <- b / a
d <- lag(a, -1)
cbind(a, b, c, d)
```
The result is a multivariate `regts`.

The code is less transparent when the chain is evaluated using a multivariate 
timeseries: 

```{r}
xts <- regts(data, start = "2010Q2", names = c("a", "x"))
xts[, "b"] <- xts[, "a"] + 1
xts[, "c"] <- xts[, "b"] / xts[, "a"]
xts["2010Q3/2011Q2", "d"] <- lag( xts[, "a"], -1)
xts
```
Note that when timeseries `d` is created you also have to select the lagged 
period. Otherwise the `xts` period is used. 
The reason is that in an assignment the period is *not* aligned.

In this case another method can be preferable. First convert the multivariate 
regts to a list of univariate timeseries with the `as.list` function. Then 
apply the `within` function. 

```{r}
xts <- regts(data, start = "2010Q2", names = c("a", "x"))
list <- as.list(xts)
list2 <- within(list, {
    b <- a + 1
    c <- b / a
    d <- lag(a, -1)
})
```

The result is a list. The timeseries in this list can be combined with a 
combination of functions `cbind` and `do.call`. Note the reverse ordering of 
the columns.

```{r}
do.call(cbind, list2)
```

The elements in the result list all have type `regts`, so the result is a 
`multivariate regts`. 

If another numeric or logical type is added to this list, it is also converted 
to a regts by `cbind`:

```{r}
list3 <- within(list2, {
    e <- 0
    f <- TRUE
})
do.call(cbind, list3)
```
\longerpage[1]
The elements `e` and `f` are repeated for the whole period and the value `TRUE` 
is coerced to `numeric`. ^[You could also add a character variable, i.e. g <- "a". 
Now the result will remain a `regts`, but all elements of the timeseries will be 
coerced to character data, which is probably not what you want.]


# Labels \label{labels}
Each timeseries in a `regts` object can be equipped with a label, a way to 
document each specific timeseries. Labels can be defined when the series are 
created and they are preserved in most timeseries functions.

```{r}
t1 <- regts(data1, start = "2017Q1", names = c("child", "adult", "senior"),
      labels = c("Age 0-17", "Age 18-65", "Age 65+"))
t1
```

As you can see the labels are not shown automatically when the timeseries are 
printed. With the `View` function you can view timeseries and their labels in 
RStudio. The result looks like this:

              child       adult       senior
           Age 0-17   Age 18-65      Age 65+
    2017Q1        1           6            3
    2017Q2        3           4            0
    2017Q3        2           8            9

The labels can also be retrieved with the `ts_labels` function:

```{r}
ts_labels(t1)
```

In combination with the `<-` operator, the `ts_labels` command can be used to 
assign labels to, or remove labels from an existing `regts`:

```{r}
tx <- regts(data, start = "2017Q1")
ts_labels(tx) <- c("Trans X", "Label X")
ts_labels(tx)
ts_labels(tx) <- NULL       # remove all labels 
ts_labels(tx)
```

For updating one or more timeseries labels in a regts object, the function `update_ts_labels` is provided:

```{r eval = TRUE}
t1_update <- update_ts_labels(t1, labels = c(adult = "Age 18-67", senior = "Age 67+"))
```
```{r echo = FALSE}
ts_labels(t1_update)
```
Argument `labels` is a named character vector with the column names as names 
and the labels as values. 

## Labels when converting `regts` to `data frame` and vice versa

Base R does not have facilities for adding labels to a data frame. However the 
`Hmisc` package has introduced a function `label` for adding label attributes 
to data frames columns and to retrieve them. 
Package `regts` uses this function to preserve the labels, when converting a 
`regts` object with labels to a `data frame` or vice versa. 

Consider the following data frame:
```{r}
df <- data.frame(child = 1:3, adult = 6:8, senior = 10:12)
rownames(df) <- c("2017", "2018", "2019")
```

Now add labels to the columns of the data frame. First load the library:
```{r}
library(Hmisc)
label(df) <- list(child = "18-", adult = "18-67", senior = "67+")
```

If you want to see the labels in the result, retrieve them with the `label` 
function^[You can also view the whole data frame including labels with the 
`View` function in Rstudio.].

```{r}
label(df)
```

When this data frame with labels is converted to a multivariate regts you can 
display the labels as usual employing the `ts_labels` function:

```{r}
tt <- as.regts(df)
ts_labels(tt)
```

Similarly, if a `regts` object with labels is converted to a data frame, then the timeseries labels are used to create the label attributes of the data frame:


## Labels when transposing a `data frame`

If a data frame contains labels, then the `transpose_df` function puts the 
labels in the first column of the result data frame.

```{r}
df
dft <- transpose_df(df)
dft
```

By default, the resulting data frame will have not labels. However, if you 
specify argument `label_column` in function `transpose_df`, then the values 
in this column are used to create labels:

\newpage

```{r collapse = TRUE}
df2 <- transpose_df(dft, label_column = "labels")
df2
label(df2)
```


## Labels in files
In this section we discuss how to read timeseries provided with labels from 
a csv file, or how to write timeseries including labels to a file. Also the 
situation is examined where label information is available on a separate file.

### Reading timeseries with labels from a file
If the timeseries are stored rowwise in a file, it is relatively easy to read 
timeseries with labels.
Consider the following csv file (the fields are separated by spaces):


```{r echo = FALSE, comment=""}
cat(readLines("tslabels.csv"), sep = "\n")
```

The first step is to read the csv file. To avoid checking period names in the 
first row use argument `check.names`.
Since the fields are separated by one or more spaces, argument `sep = ""` is used.

```{r}
df <- read.csv("tslabels.csv", stringsAsFactors = FALSE, check.names = FALSE, sep = "")
df
```
Next the data frame has to be transposed. In the function `transpose_df` it is 
possible to indicate which column contains the names and which column contains 
the labels: use arguments `colname_column` and `label_column`. 

```{r}
dft <- transpose_df(df, colname_column = "name", label_column = "label")
dft
```
Now we convert the data frame to a `regts` and check the labels:

```{r}
tsl <- as.regts(dft)
ts_labels(tsl)
```

The timeseries can also be stored columnwise as in the following csv file:

```{r echo = FALSE, comment=""}
cat(readLines("testlabels.csv"), sep = "\n")
```

When reading the file we use argument `row.names = 1` to get the period, which 
is in the first column, as row names.

```{r}
df <- read.csv("testlabels.csv", stringsAsFactors = FALSE, row.names = 1)
df
```
We store the labels in a character variable and then remove the label row.

```{r}
labels <- as.character(df[1, ])
labels
df <- df[-1, ]
df
```
A data frame column can contain only one type of data^[Different columns in a 
data frame may contain different types of data.]. The label row in the data 
frame has type character, so all data in data frame `df` are characters. 
They have to be converted to numeric data. Function `as.regts` takes care of 
that. 
Finally the timeseries is created and the labels are assigned using the 
`ts_labels` function:

```{r}
tsl <- as.regts(df)
ts_labels(tsl) <- labels
```

\newpage
### Separate label files

Suppose we have a file with label information. This label file contains a list 
of timeseries names and the corresponding labels:

```{r echo = FALSE, comment=""}
cat(readLines("label.csv"), sep = "\n")
```

There is also a `regts` object which contains two timeseries: `c` and `b`.

```{r}
ts <- regts(matrix(1:4, ncol=2), names = c("c","b"), start = "2016")
```

The label file contains the labels for the two timeseries.
We want to add these labels to the timeseries. First the label file is read:

```{r}
dflabel <- read.csv("label.csv", stringsAsFactors = FALSE)
dflabel
```

To update the timeseries labels the function `update_ts_labels` can be used.
Input for the labels in this function is a named character vector. The label 
vector is fetched from the `dflabel` data frame variable and the names can be 
set with the `names` function:

```{r}
labels <- dflabel[[2]]
names(labels) <- dflabel[[1]]
labels
```
The variable `labels` contains more labels than necessary. Also the ordering 
of the labels is not the same as in the  column names of the regts object. This 
is not a problem, the function `update_ts_labels` takes care of all that:

```{r}
ts <- update_ts_labels(ts, labels)
```

This is the result ( of `view(ts)`):

            c         b
            label_c   label_b
    2016          1         3
    2017          2         4

\newpage
    
### Writing timeseries with labels to file

It is also possible to write timeseries together with the labels to a file. 
The easiest way is to create a transposed data frame with labels. 

```{r}
ts_data <- regts(matrix(1:8, ncol = 2), start = "2016Q1", end = "2016Q4",
                 names = c("a", "b"), labels = c("Series_a", "Series_b"))
df  <- as.data.frame(ts_data)
dft <- transpose_df(df)
dft
```

This data frame can be written to file.
```{r}
write.csv(dft, "result_label.csv")
```


# Differences between multivariate timeseries
It can be quite tedious to compare two multivariate timeseries with a large 
number of columns. 
The function `tsdif` is specially designed to compare two multivariate timeseries 
objects with the same frequency.
The function calculates differences between columns with the same name, they do 
not have to be in the same order.
The actual function used to compute the differences can be specified, by default 
absolute differences are computed.
Also argument `tol` can be specified: all differences smaller than `tol` will be 
ignored. By default `tol` is 0.


```{r}
rt1 <- regts(matrix(1:12, ncol = 3), start = "2016Q1", names = c("a", "b", "c"))
# create timeseries with slight differences, larger and smaller than the tolerance factor 
rt2 <- rt1
rt2[ ,"a"] <- rt1[ ,"a"] + 0.01
rt2[ ,"b"] <- rt1[ ,"b"] + 1e-6
rt2
tsdif(rt1, rt2, tol = 1e-3)
``` 

The result is a list with several components, starting with the result `equal`, 
which is `TRUE` or `FALSE`. 
The names of the common columns with differences larger than the tolerance `tol` 
appear in `difnames`. 
In this example `equal` is `FALSE`, because there are differences larger than 
the tolerance between the "a" columns, which is shown at `difnames`. 
Component `dif` is a `regts` with the computed differences of these columns. 
If there are no differences `dif` becomes `NULL`. In this case the difference 
between columns `a` is equal for all quarters: 0.01.
In the `missing_names` variables the not common columns appear. In this example 
there are no missing names. The tolerance argument `tol`, with value 0.001, is 
an input argument and added for the sake of completeness.

In the previous example the two objects had the same column names. Now we discuss 
an example where the column names are different.
We create a new timeseries `rt3`, an extension of timeseries `rt1` with an extra 
column:

```{r}
rt3 <- rt1
rt3[, "d"] <-  regts(9:12, start = "2016Q1")
tsdif(rt1, rt3, tol = 1e-3)
```
The `missing_names1` component contains the column names in the second timeseries 
that are missing in the first timeseries, in this case variable `d`. There are no `missing_names2`.

All computed differences are smaller than or equal to the tolerance factor, so 
component `dif` is `NULL`. Component `equal` is still FALSE, because there are 
missing names.
The `equal` component is only `TRUE` if both component `dif` is `NULL` and there 
are no missing names. 

Let's compare two columns of regts objects `rt1` and `rt2`. Columns `b` differ 
less than the tolerance factor and columns `c` are equal. Now the result is equal:

```{r}

dif_b <- tsdif(rt1[, c("b","c")], rt2[, c("c","b")], tol = 1e-5)   
dif_b$equal
```
As you can see the ordering of the columns makes no difference.


# Aggregate functions
The function `aggregate` can be used to convert a timeseries to a lower frequency. 
For example to convert a monthly timeseries to a quarterly timeseries, or a 
quarterly timeseries to a yearly timeseries.

An example with a monthly timeseries:

```{r}
regtm1 <- regts(1:24, start = "2016M1")
regtm1
aggregate(regtm1, FUN = mean, nfrequency = 4)
```

And another with a quarterly timeseries:
```{r}
regt1 <- regts(1:10, start = "2016Q1")
regt1
```
```{r results = "hide"}
aggregate(regt1, FUN = sum)
```

When the newlines are removed the result looks like this:

    regt1  Time Series: Start = 2016  End = 2017  Frequency = 1  [1] 10 26

The quarters in 2016 add up to 10, the quarters in 2017 to 26. Note that the 2 
quarters in 2018 are ignored. The `aggregate` function skips the incomplete 
years at the end.

A special situation occurs when for instance a quarterly timeseries doesn't 
start in the first 
quarter:
```{r}
regt2 <- regts(2:10, start = "2016Q2")
regt2
```
```{r results = "hide"}
aggregate(regt2, FUN = sum)
```
Now the result is:

    regt2  Time Series: Start = 2017     End = 2017     Frequency = 1  [1] 26

The quarters in 2017 add up to 26 as before. But now the information for 2016 
is also not complete, and therefore ignored. This is what you would expect: 
for `regts` objects the `aggregate` function skips all years for which not all 
quarters are present.
 
Usually the `aggregate` function works the same for `regts` and `ts`, but in 
this case the result is very different. The same example with a `ts` timeseries:

```{r results = "hide"}
t2    <- ts(2:10, start = c(2016,2), frequency = 4)
aggregate(t2, FUN = sum)
```
The result is:

    t2     Time Series: Start = 2016.25  End = 2017.25  Frequency = 1  [1] 14 30
    
Now the first year (2016) is not ignored. This leads to a shifted result period 
(the start is `2016.25`) and shifted input (14 = 2 + 3 + 4 + 5), which makes the 
results peculiar.^[This problem does not occur when a quarterly timeseries ends 
before the last quarter, or before the end of the quarter in case of a monthly 
timeseries. Then the last year or quarter is ignored.].

So the function `aggregate` operates differently for a `regts` or a `ts` object, 
if the first period does not start at a subperiod for the new frequency.

## Aggregation for growth timeseries 
Another case is the treatment of timeseries that contain absolute, relative or 
percentage changes.
For this case the function `aggregate_gr` is developed with special aggregation algorithms, the so called 'cumulative growth'-methods.
A more detailed description of these methods can be found in the next subsection.
This function can be employed for both `regts` and `ts` timeseries. 

All methods convert input timeseries with high frequency to low frequency 
outputseries. There are four different type of methods for different types of 
input timeseries:

The `dif1s` and `dif1` methods assume that the input timeseries is a first 
difference of length 1 in the input frequency (for `dif1s` the input is also 
scaled) and calculate a first difference of length 1 in the output frequency. 

The `pct` and `rel` methods assume that the input timeseries is a one-period 
relative or percentage change and calculate the exact relative or percentage 
change for the output timeseries.

First a timeseries is created containing differences:
```{r}
xdif <- diff(regts(c(1,3,4,3,6,2,4,1,3,2), start = "2015Q4"))
xdif
```

Two examples of aggregation methods are shown:

```{r}
aggregate_gr(xdif, method = "dif1s", nfrequency = 1)  # result is a yearly timeseries
```
  
```{r}
aggregate_gr(xdif, method = "dif1")
```

### The cumulative growth methods 
The so called growth timeseries require special methods, a simple averaging of 
the subperiods in the high frequency observations will not return the correct 
answer. 
In this section a more detailed description of the four previously defined 
frequency conversion methods is given.

In advance some definitions are needed:  

We are temporally aggregating a timeseries $x$ with $n$ subperiods to a 
timeseries $X$ with a
lower frequency. In other words we want to convert a timeseries x with a high 
frequency
(monthly, quarterly) to a new timeseries with a lower frequency (quarterly, 
annual).

Let $x_{t,i}$   stand for the value of $x$ in subperiod $i$ of main period $t$.
The index $i$ takes on values in the range $1 .. n$.
We always interpret $x_{t,0}$ to mean $x_{t-1,n}$.
The time index $t$ refers to the periods in the time domain of $X$.
Many conversion methods only need the observations subperiod $i$ of main period $t$.
For example the \texttt{mean} method calculates $X_t$ as follows
\begin{displaymath}
X_t = \sum_{i=1}^{i=n} x_{t,i}/n
\end{displaymath}

### `dif1s` method {-} 
Define $x$ to be the first difference  of $z$ scaled to the output frequency.
Thus
\begin{displaymath}
 x_{t,i} = n ( z_{t,i} - z_{t,i-1} )
\end{displaymath}
We can also define $z_{t,i}$ in terms of $x$ as follows
\begin{eqnarray*}
z_{t,i} & = & z_{t,i-1} + x_{t,i}/n\\
        & = & z_{t-1,n} + \sum_{j=1}^{i} x_{t,j}/n
\end{eqnarray*}
Now define $Z_t$ as the level timeseries in time domain $t$ corresponding
to $z$
\begin{eqnarray*}
Z_t &=& \sum_{i=1}^{n} z_{t,i}\\
    &=& \sum_{i=1}^{n} z_{t-1,n} + \sum_{i=1}^{n} \sum_{j=1}^{i} x_{t,j}/n\\
    &=& \sum_{i=1}^{n} z_{t-2,n} + \sum_{i=1}^{n} \sum_{j=1}^{n} x_{t-1,j}/n + \sum_{i=1}^{n} \sum_{j=1}^{i} x_{t,j}/n
\end{eqnarray*}
Then $X$ in any period $t$ can be calculated from
\begin{displaymath}
X_t = Z_t - Z_{t-1}
\end{displaymath}
Since $Z_{t-1}$ can be written as
\begin{displaymath}
Z_{t-1} = \sum_{i=1}^{n} z_{t-2,n} + \sum_{i=1}^{n} \sum_{j=1}^{i} x_{t-1,j}/n\\
\end{displaymath}
it is easy to show that $X_t$ does not depend on $z_{t-2,n}$.
In any practical algorithm $z_{t-2,n}$ can be set to 0.

A compact equation for $X_t$ can be derived by substituting the equations for
$Z_t$ and $Z_{t-1}$ into the definition of $X_t$
\begin{displaymath}
X_t = \sum_{i=1}^n
        \left(
          \sum_{j=i+1}^n x_{t-1,j} + \sum_{j=1}^i x_{t,j}
        \right) / n
\end{displaymath}
This expression can be futher simplified by changing the order of summation.
For the first summation, we can write
\begin{eqnarray*}
 \sum_{i=1}^n  \sum_{j=i+1}^n x_{t-1,j} &=&  \sum_{j=2}^n  \sum_{i=1}^{j-1} x_{t-1,j} \\
                                        &=&   \sum_{j=2}^n  (j-1) x_{t-1,j}
\end{eqnarray*}
Similarly,
\begin{eqnarray*}
 \sum_{i=1}^n  \sum_{j=1}^i x_{t,j}  &=&  \sum_{j=1}^n  \sum_{i=j}^{n} x_{t,j} \\
                                        &=&   \sum_{j=1}^n  (n - j + 1) x_{t,j}
\end{eqnarray*}

The final equation is given by
\begin{displaymath}
X_t =  \left(  \sum_{j=2}^n  (j-1) x_{t-1,j} -    \sum_{j=1}^n  (n - j + 1) x_{t,j} \right) / n
\end{displaymath}


### `dif1` method {-}
Define $x$ to be the first difference  of $z$. Thus
\begin{displaymath}
 x_{t,i} = z_{t,i} - z_{t,i-1}
\end{displaymath}
We can also define $z_{t,i}$ in terms of $x$ as follows
\begin{eqnarray*}
z_{t,i} & = & z_{t,i-1} + x_{t,i}\\
        & = & z_{t-1,n} + \sum_{j=1}^{i} x_{t,j}
\end{eqnarray*}
Further derivations are analogous to the case for the \texttt{dif1s} method
described in the previous section.

### `rel` method {-}
Define $x$ to be the relative change in $z$. Thus
\begin{displaymath}
 x_{t,i} = (z_{t,i} - z_{t,i-1}) / z_{t,i-1}
\end{displaymath}
We can also define $z_{t,i}$ in terms of $x$ as follows
\begin{eqnarray*}
z_{t,i} & = & z_{t,i-1}(1 + x_{t,i})\\
        & = & z_{t-1,n}  \prod_{j=1}^{i}(1+ x_{t,j})\\
        & = & z_{t-2,n} \prod_{j=1}^{n}(1+ x_{t-1,j}) \prod_{j=1}^{i}(1+ x_{t,j})
\end{eqnarray*}
Now define $Z_t$ as the level timeseries in time domain $t$ corresponding
to $z$
\begin{eqnarray*}
Z_t &=& \sum_{i=1}^{n} z_{t,i}\\
    &=&  z_{t-1,n} \sum_{i=1}^{n} \prod_{j=1}^{i}(1+ x_{t,j})\\
    &=&  z_{t-2,n} \prod_{j=1}^{n}(1+ x_{t-1,j}) \sum_{i=1}^{n} \prod_{j=1}^{i}(1+ x_{t,j})
\end{eqnarray*}
Then $X$ in any period $t$ can be calculated from
\begin{displaymath}
X_t = Z_t / Z_{t-1} - 1
\end{displaymath}
Using the expression for $Z_{t-1}$
\begin{displaymath}
Z_{t-1} = z_{t-2,n}  \sum_{i=1}^{n} \prod_{j=1}^{i}(1+ x_{t-1,j})
\end{displaymath}
we obtain
\begin{displaymath}
X_t = \frac{\prod_{j=2}^{n}(1+ x_{t-1,j}) \sum_{i=1}^{n} \prod_{j=1}^{i}(1+ x_{t,j})}
{1 + \sum_{i=2}^{n} \prod_{j=2}^{i}(1+ x_{t-1,j})} - 1
\end{displaymath}

### `pct` method {-}
Define $x$ to be the percentage change in $z$. Thus
\begin{displaymath}
 x_{t,i} = 100 (z_{t,i} - z_{t,i-1}) / z_{t,i-1}
\end{displaymath}
We can also define $z_{t,i}$ in terms of $x$ as follows
\begin{eqnarray*}
z_{t,i} & = & z_{t,i-1}(1 + 0.01 x_{t,i})\\
        & = & z_{t-1,n} \prod_{j=1}^{i}(1+0.01 x_{t,j})
\end{eqnarray*}
Now define $Z_t$ as the level timeseries in time domain $t$ corresponding
to $z$
\begin{displaymath}
Z_t = \sum_{i=1}^{n} z_{t,i}
\end{displaymath}
Then $X$ in any period $t$ can be calculated from
\begin{displaymath}
X_t = 100(Z_t / Z_{t-1} -1)
\end{displaymath}
Further derivations are analogous to the case for the \texttt{dif1s} method
described in the previous section.

<!--
-->













