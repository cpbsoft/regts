
---
title: "Introduction to package regts"
author: "Rob van Harrevelt and Anita van der Roest"
date: '`r Sys.Date()`'
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
linkcolor: blue    
---
<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{Introduction package regts}
-->

\newcommand{\longerpage}[1][1]{\enlargethispage{#1\baselineskip}}
\newcommand{\shorterpage}[1][1]{\enlargethispage{-#1\baselineskip}}
%
\newcommand{\needlines}[1]{\Needspace{#1\baselineskip}}

```{r echo = FALSE, message = FALSE}
library(regts)
library(Hmisc)
#library(xlsx)
data <- matrix(c(3,2,4,3,5,2,5,3), ncol = 2)
data1 <- matrix(c(1,3,2,6,4,8,3,0,9), ncol = 3)

# input/output chunks are separated
# R inputlines start with >, outputlines with nothing
knitr::opts_chunk$set(collapse = FALSE, comment = "", prompt = TRUE)

```
\longerpage[1]

\newpage

# Introduction

When you start looking in R for timeseries you easily find several 
classes and packages, class `ts` from the `stats` package and `zoo` being mentioned most.

The function `ts` creates a regular timeseries object with class `ts`. This can be a univariate or multivariate object. It has a start, an end, a frequency and you can print, plot, extend and update it. But class `ts` has no easy way to deal with fixed periods. 

`Regts` is a package defined for regular timeseries objects built on class `ts`, but with features for easier selecting periods. The `regts` package defines a class `regts` that is an extension to the `ts` class.
Because of this the `regts` class benefits of all the functionality of `ts`.
The period handling is much easier than in the `ts` class, particularly for 
monthly, quarterly and annual timeseries.

Package `xts` also facilitates period selection, but concentrates more on daily (or weekly) based data. 
 
Package `regts` provides some more extensions to package `ts`: 

* the use of labels, a description of the timeseries
* an easy way to convert a data frame to a timeseries object
* a function to calculate differences between multiple timeseries
* and furthermore a special set of aggregation functions for timeseries 
representing growth rates

To use this package `regts` load it with:
```{r eval = FALSE}
library(regts)
```


# Creation `regts`

## Single timeseries
A single `regts` timeseries is created with the function `regts`. An example for 
a quarterly timeseries:

```{r echo = 1}
tq <- regts(1:10, start = "2016Q3")
tq
```
The end period of the timeseries is based on the length of the input data.
The period can also be a month, like `"2016M3"`, or a year: 

```{r echo = 1}
ty <- regts(c(.11, .29, .18, .24), start = "2017")
ty
```
Note that annual timeseries are printed differently than quarterly timeseries.

The `class` of `tq` and `ty` is `regts`, and because of the inheritance, also `ts`.
```{r}
class(tq)
```

If the input data is longer than you require you can make a selection with the 
`end` argument:

```{r}
ts_data <- regts(1:10, start = "2016Q1", end = "2016Q4")
```
If the input data is shorter than the period determined by the `start` and the 
`end` argument, the data is repeated:

```{r}
ts_data <- regts(1:2, start = "2016Q1", end = "2017Q1")
ts_data
```
As you can see the length of the period doesn't have to be a multiple of the 
length of the input data.

Class `regts` recognizes special formats for quarterly (`2016Q1`) and monthly 
(`2016M1`) timeseries.
To create timeseries with a different frequency, specify the frequency argument:

```{r}
ts_data <- regts(1:10, start = "2016-1", end = "2017-1", frequency = 2)
```

Instead of arguments `start` and `end` you can also specify argument `period`:
```{r}
ts_data <- regts(1:10, period = "2016Q1/2016Q4")
```
Input for this period may be a character string as shown above, but also a 
variable of type  `period_range`. This type will be explained in section 
\ref{period}.

## Multivariate timeseries \label{multits}
Sometimes it is more convenient to combine several timeseries with the same 
period in a single object: a multivariate timeseries. 
A multivariate timeseries is just a matrix with two or more columns.
multivariate `regts` is such a matrix with some extra attributes. 

```{r}
rts <- regts(matrix(1:9, ncol = 3), start = "2016Q1", names = c("a", "b", "c"))
rts
```
Argument `names` can be used to set the column names. If omitted then the 
column names of the input matrix are used. In the next example the input 
matrix has no column names:

```{r}
rts1 <- regts(matrix(1:9, ncol = 3), start = "2016Q1")
rts1
```

A multivariate timeseries inherits the classes `mts` (multivariate `ts`), 
`ts` and `matrix`:

```{r}
class(rts)
```

Timeseries names are preferably valid R names (only include a-z, A-Z, _, 
and 0-9 and start with a letter) and well chosen. In general they will be brief. 
If more documentation is needed for a timeseries than just this (short) name, 
optionally labels can be added (see also section [labels](#labels)).


### Column selection and creation

Column selection for regts is the same as for matrices. 

```{r}
a1_ts <- rts[ , "a"]
a1_ts
ac_ts <- rts[ , c("a", "c")]
ac_ts
```
`a1_ts` is now a univariate timeseries, `ac_ts` a multivariate subset of `rts`. 

For the `regts` class we can also create new columns:

```{r}
rts[, "x"] <- 2 * rts[, "a"]  # creating a new column "x"
rts
```

This is not possible for classes `ts` and `matrix`.


### Selecting columns with a regular expression
The `regts` package contains a function `select_columns` to select columns of 
an R object with column names. Besides `regts` this can be a `matrix` or a 
`data frame`. The columns with names matching a given regular expression are 
selected. A few examples:

```{r}
rts <- regts(matrix(1:8, ncol = 4), start = "2016Q1", names = c("a1", "b1", "a2", "b2"))
select_columns(rts, regex = "a.*")  # all columns with names starting with "a"
select_columns(rts, regex = ".+1")  # all columns with names ending with 1
```

The syntax of `regular expression` patterns is described in the R Documentation.


## Matrices with one column
If a `regts` is created from a matrix with only one column, the timeseries is 
single (or univariate). So there are two types of single timeseries: one that 
is based on a vector and one that is based on a one-column matrix: 

```{r}
ts      <- regts(1:8, start = "2016Q1")
ts_1col <- regts(matrix(1:8, ncol = 1), start = "2016Q1")
```
They have identical output:
```{r}
ts
ts_1col
```
and identical classes:

```{r}
class(ts)
class(ts_1col)
```

but different underlying data.

Another difference between the 'vector' version and the 'matrix-1-column' 
version is that the latter can have a column name:

```{r}
ts_1col <- regts(matrix(1:8, ncol = 1), start = "2016Q1", names = "a")
```
The column name is not printed with the output, but can be shown with the 
`View` or the `colnames` function:

```{r}
colnames(ts_1col)
```

Single 'vector' timeseries never have a column name.

A single 'matrix-1-column' timeseries is also created when a single column 
is selected from a multivariate timeseries with the argument `drop = FALSE`. 
In this case the column name is preserved. If this argument is omitted 
(or `drop = TRUE` is used) a single 'vector' timeseries is created. A possible 
column name disapppears in this case. An example:  

```{r results = "hide"}
rts <- regts(matrix(1:8, ncol = 2), start = "2016Q1", names = c("a", "b"))

rts[ ,1, drop = FALSE] # result is a one-dimensional matrix with column name "a"
rts[ ,2]               # result is a vector, column name "b" is lost
```

\newpage
# Period selection \label{periodselection}

The package `regts` is specially designed for the selection of periods. Where 
for a `ts` timeseries you have to use the `window` function:

```{r}
ts <- ts(c(1,2,3,4,5,6,7,8), start=c(2016,1), end=c(2017,4), freq=4)
window(ts, start = c(2016,4), end = c(2017,2))
```

with a `regts` you can select periods with the selection operator `[]`. Period 
selection is a form of subsetting. 

```{r results = "hide"}
ts <- regts(1:8, start = "2016Q1", end = "2017Q4")
ts["2016Q4/2017Q2"]
```
Besides a range you can also select one period:

```{r results = "hide"}
ts["2017Q1"]
```    
    
or a range with an open beginning or end:

```{r results = "hide"}
ts["/2017Q2"]
ts["2017Q1/"]
```
or a range with a lower frequency:

```{r}
ts["2017"]
```

If a selection is specified outside the defined range, the timeseries is filled 
with NA values for that range:

```{r}
ts["/2018Q2"]
ts["2015Q3/"] 
```

Period selection can also be applied on the left hand side of an assignment, in 
the target timeseries. The object must exist before applying selection.

```{r}
rts1 <- regts(1:8, start = "2010Q1", end = "2011Q4")
rts1["2011Q2"] <- 2
rts1["/2010Q3"] <- 99
rts1
```

The period of the timeseries can also be extended:
```{r}
rts1["2009Q1/2009Q2"] <- rts1["2010Q3/2010Q4"]
rts1
```
The missing quarters (`2009Q3` and `2009Q4`) are filled in with NA values.

<!-- Special header: a bold line with some whitespace before, because we
want no header in the table of contents -->
&nbsp;  
**Period selection for multivariate regts**

Selecting a period for a multivariate regts is quite similar. You can select 
one or more periods, or a combination of period(s) and columns:

```{r}
rts <- regts(matrix(1:12, ncol = 3), start = "2011Q1", names = c("a", "b", "c"))
rts["2011Q2", ]

rts["2011Q2"]                 # the , is not necessary

rts["2011Q1/2012Q2", "c"]     # extended selection
```

All the extended elements become NA.

Select a combination of period and columns:

```{r}
rts["2011Q4/", c("a", "b")]
```

Selection can also take place in the target timeseries:

```{r echo = 1:3}
rts[, "x"] <- NA              # define an extra column
rts["2012Q1", ] <- 99         # extend period for all columns 
rts["2011", "x"] <- 1         # update all quarters in 2011 in column "x"
rts
```


\newpage
# Reading and writing timeseries 

Some common used file types to store data in R are Rdata, csv or xls(x) files.
Inside R projects, preferably use Rdata files. Writing and reading R objects to 
and from Rdata files is easy and efficient.
If data has to be exported, you can use for example csv or Excel files.

## `.rds` file
The `.rds` file, an R-readable binary file, is the most flexible file type
A single object can be stored by the `saveRDS` function in the `base` package.

```{r}
saveRDS(df, file = "output.rds")
```
The `.rds` file extension is most often used.

An object saved in such `.rds` file can be reloaded  by the `readRDS` function.
(Possibly under a different name.)

```{r}
readRDS("output.rds")
```

Besides these, functions `save` and `load` are available. They save and restore
single and multiple objects. It is also possible to store the entire workspace.


## External files

Most functions in R for reading a csv or Excel file, return a `data frame`. 
This type can easily be converted to a `regts`, as will be explained in section 
\ref{dataframe}. 
Convenience functions have been developed for reading timeseries (`regts`
objects) from a csv or Excel file. Equivalent functions exist for writing 
timeseries to a csv or Excel file.

### Reading and writing csv files
With the `read_ts_csv` function a `regts` variable can be read from a csv file.
This function has several handy parameters to deal with separators, empty rows
or columns and labels. In most cases it succeeds in finding the correct 
frequency and determining how the timeseries are stored: rowwise or columnwise.
If not, extra input parameters can be given.

Consider the following csv file 

```{r echo = FALSE, comment=""}
cat(readLines("test.csv"), sep = "\n")
```

Notice that the periods are in the first column, the other columns contain the
timeseries. The following command will do:


```{r}
read_ts_csv("test.csv")
```

The function has an argument `rowwise`. We could have used `rowwise = FALSE` to
indicate that the timeseries are stored columnwise. But in this case is is not
needed, the period column is recognised by the program.

Sometimes the csv file is transposed, as in the following example:

```{r echo = FALSE, comment=""}
cat(readLines("transpose.csv"), sep = "\n")
```

Now the periods are in the first row (column headers), the next rows contain the 
timeseries. Note that `;` is the field separator and that quarter `2017Q3` is
missing in the file.


```{r}
read_ts_csv("transpose.csv", sep = ";")
```

Since `regts` (&aacute;nd `ts`) objects always have a continuous period^[`regts` 
and `ts` objects are regular timeseries. Packages `xts` and `zoo` provide also 
irregularly spaced timeseries objects. Then periods can be missing.], the missing 
quarters are filled with NA values. 

The timeseries names in this file are in uppercase. You can convert them while
reading:

```{r}
read_ts_csv("transpose.csv", sep = ";", name_fun = tolower)
```

Files may be more complicated then the examples shown above. Possibly there 
are comments, extra rows or columns, or redundant information in the file. 
Most files will be read without problems. If necessary, use arguments `skiprow`
and `skipcol`.


Use function `write_ts_csv` to store a `regts` timeseries in a csv file.
By default the timeseries are stored rowwise (i.e. the period is written in the
first row). If labels are present, they are by default written after the names.

```{r}
rts <- regts(matrix(1:8, ncol = 2), start = "2016Q1", names = c("a","b"))
write_ts_csv(rts, "result.csv")
```

You may want to write the data in transposed form, without labels:

```{r}
write_ts_csv(rts, "result_transposed.csv", rowwise = FALSE, labels = "no")
```

More information about labels can be found in section \ref{labels}.

### Reading and writing Excel files
Special functions have been developed for `regts` objects

* `read_ts_xlsx` (based on the `read_excel` function in package `readxl`) for 
reading an Excel file, both for `xls` and `xlsx` format

* `write_ts_xlsx` for writing an xlsx file

Like the corresponding csv function, `read_ts_xlsx` has parameters for handling
empty rows or columns, lables, orientation and frequency. Besides that you can
specify a sheet, a range and how to recognise na-strings. Consider the next
xlsx file:

```{r echo = FALSE, comment=""}
cat(readLines("series.csv"), sep = "\n")
```

When reading this file a `regts` object is returned:

```{r}
read_ts_xlsx("series.xlsx", skiprow = 2, name_fun = tolower, na_string = c("","NA"))
```

The function skips the first 2 lines, analyses where the period begins, converts
the timeseries names to lowercase and recognises that empty cells and cells with
text 'NA' are not available.

Function `write_ts_xlsx` is used for writing a `regts` object to an xlsx file.
It creates or opens an Excel workbook depending on argument `append`. Appending
to a non existent file means creating the file. You can specify the sheetname 
(by default Sheet1) and whether you want to write labels. An example:

```{r}
write_ts_xlsx(rts, "data.xlsx", sheet_name = "extra", append = TRUE)
```

In this case a sheet 'extra' is appended to the xlsx file.

\newpage

# Labels \label{labels}
Each timeseries in a `regts` object can be equipped with a label, a way to 
document each specific timeseries. Labels can be defined when the series are 
created and they are preserved in most timeseries functions.

```{r}
t1 <- regts(data1, start = "2017Q1", names = c("child", "adult", "senior"),
      labels = c("Age 0-17", "Age 18-65", "Age 65+"))
t1
```

As you can see the labels are not shown automatically when the timeseries are 
printed. With the `View` function you can view timeseries and their labels in 
RStudio. The result looks like this:

              child       adult       senior
           Age 0-17   Age 18-65      Age 65+
    2017Q1        1           6            3
    2017Q2        3           4            0
    2017Q3        2           8            9

The labels can also be retrieved with the `ts_labels` function:

```{r}
ts_labels(t1)
```

In combination with the `<-` operator, the `ts_labels` command can be used to 
assign labels to, or remove labels from an existing `regts`:

```{r}
tx <- regts(data, start = "2017Q1")
ts_labels(tx) <- c("Trans X", "Label X")
ts_labels(tx)
ts_labels(tx) <- NULL       # remove all labels 
ts_labels(tx)
```

For updating one or more timeseries labels in a regts object, the function 
`update_ts_labels` is provided:

```{r eval = TRUE}
t1_update <- update_ts_labels(t1, labels = c(adult = "Age 18-67", senior = "Age 67+"))
```
```{r echo = FALSE}
ts_labels(t1_update)
```
Argument `labels` is a named character vector with the column names as names 
and the labels as values. 


## Labels in files
In this section we discuss how to read timeseries provided with labels from 
a csv or xls(x) file, or how to write timeseries including labels to a file. 
Also the situation is viewed where label information is available on a separate 
file.

### Reading timeseries with labels from a file
It is easy to read timeseries with labels from a csv or xls(x) file, provided
that the labels are placed before or after the timeseries names. Read the
following Excel file including the labels:

```{r echo = FALSE, comment=""}
cat(readLines("tslabels.csv"), sep = "\n")
```

```{r}
series <- read_ts_xlsx("tslabels.xlsx", labels = "after")
```

Now check the labels:

```{r}
ts_labels(series)
```

Labels and timeseries can also be stored columnwise:

```{r echo = FALSE, comment=""}
cat(readLines("testlabels.csv"), sep = "\n")
```

Read this file with result `tseries` and look at the labels:


```{r}
tseries <- read_ts_xlsx("testlabels.xlsx", labels = "after")
ts_labels(tseries)
```

### Reading labels from a separate file

Suppose we have a file with label information. This label file contains a list 
of timeseries names and the corresponding labels:

```{r echo = FALSE, comment=""}
cat(readLines("label.csv"), sep = "\n")
```

There is also a `regts` object which contains two series: `c` and `b`.

```{r}
ts <- regts(matrix(1:4, ncol=2), names = c("c","b"), start = "2016")
```

We want to add some labels from this file to the timeseries using the function
`update_ts_labels`. Input for this function is a named character vector
containing the labels.

The label file contains the labels for the two timeseries.
Variable `dflabel` is read from the file as a `data frame` using function
`read.csv`:


```{r}
dflabel <- read.csv("label.csv", stringsAsFactors = FALSE)
dflabel
```

With the `dflabel` variable a named character vector `labels` is constructed.
The names can be set with the `names` function:

```{r}
labels <- dflabel[[2]]
names(labels) <- dflabel[[1]]
labels
```
The variable `labels` contains more labels than necessary. Also the ordering 
of the labels is not the same as in the  column names of the regts object. This 
is not a problem, the function `update_ts_labels` takes care of all that:

```{r}
ts <- update_ts_labels(ts, labels)
```

This is the result ( of `view(ts)`):

            c         b
            label_c   label_b
    2016          1         3
    2017          2         4


    
### Writing timeseries with labels to file

Functions `write_ts_csv` and `write_ts_xlsx` write timeseries to file 
automatically including the labels. By default they are written after the names.
Specify `labels = "before"` to write the labels before the names and specify
`labels = "no"` to prevent the labels being written. An example:

```{r}
ts_data <- regts(matrix(1:8, ncol = 2), start = "2016Q1", end = "2016Q4",
                 names = c("a", "b"), labels = c("Series_a", "Series_b"))
write_ts_xlsx(ts_data, "result_label.xlsx", labels = "no")
```

## Labels when converting `data frame` to `regts` and vice versa

Base R does not have facilities for adding labels to a data frame. However the 
`Hmisc` package has introduced a function `label` for adding label attributes 
to data frames columns and to retrieve them. 
Package `regts` uses this function to preserve the labels, when converting a 
`regts` object with labels to a `data frame` or vice versa. 

Consider the following data frame:
```{r}
df <- data.frame(a = 1:3, b = 6:8, c = 10:12)
rownames(df) <- c("2017", "2018", "2019")
```

Now add labels to the columns of the data frame. First load the library:
```{r}
library(Hmisc)
label(df) <- list(a = "aap", b = "noot", c = "mies")
```

If you want to see the labels in the result, retrieve them with the `label` 
function^[You can also view the whole data frame including labels with the 
`View` function in Rstudio.].

```{r}
label(df)
```

When this data frame with labels is converted to a multivariate regts you can 
display the labels as usual employing the `ts_labels` function:

```{r}
tt <- as.regts(df)
ts_labels(tt)
```

Similarly, if a `regts` object with labels is converted to a data frame, then 
the timeseries labels are used to create the label attributes of the data frame.

```{r}
ts_data <- regts(matrix(1:8, ncol = 2), start = "2016Q1", end = "2016Q4",
                 names = c("a", "b"), labels = c("Series_a", "Series_b"))
df1 <- as.data.frame(ts_data)
label(df1)
```

## Labels when transposing a `data frame`

Package `regts` disposes of a transpose function for a `data frame`, function
`transpose_df`. If a data frame contains labels, then this `transpose_df`
function puts the labels in the first column of the result data frame.
(variable `df` in the next example is previously defined)

```{r}
df
dft <- transpose_df(df)
dft
```

Thus, by default, the resulting data frame will have not labels. However, if you 
specify argument `label_column`, then the values in this column are used to 
create labels:

```{r collapse = TRUE}
df2 <- transpose_df(dft, label_column = "labels")
df2
label(df2)
```

# Operators and functions for `regts`
Since the `regts` class is an extension of the `ts` class all functionality 
from this class is available.
All arithmetic (`+`, `-`, `*`, `/`, `^`, `%%`, `%/%`), logical (`&&`, `||`, `!`), relational (`==`, `!=`, `<`, `<=`, `>`, `>=`) and subsetting (`[]`) operators 
applicable for a `ts` variable, can be used for a `regts` timeseries. 
Some examples:

```{r}
tx <- regts(1:10, start = "2017Q1")

# operators
ty    <- 2*tx + 1
tpyth <- tx^2 + ty^2   
modulo <- tx %% 2
tlog  <- tx < ty && ty > 1
number <- tx["2017Q2"]

```
When a binary arithmetic operator is used on two timeseries objects, the 
intersection of the periods is taken:

```{r}
tx <- regts(1:6, start = "2016Q1")
ty <- regts(1:6, start = "2017Q1")
tx + ty
```

You can use all functions applicable to a `ts` class timeseries. Some examples:
```{r, eval = FALSE}
tsin <- sin(tx)
tlog <- log(tx)
diff(tx)
plot(tx)
```

&nbsp;  
**Combining timeseries**

As we have seen all functions that are available for `ts` are also available 
for `regts`. The `cbind` function (an S3 generic function) is one of them: it 
binds two or more objects with a common frequency. With the `cbind` function 
it is easy to combine several univariate timeseries to a multivariate timeseries, 
or a combination of univariate and multivariate timeseries to a new multivariate timeseries. 

Yet the extension for `regts` has special features: arguments `union` and `suffixes`. 

The argument `union` effects the period range. With `union = TRUE`, the default 
value, the union of the period ranges of the joined objects is taken, otherwise 
it is the `intersection`. An example:

```{r}
rt1 <- regts(1:4, start = "2016Q1")
rt2 <- regts(1:4, start = "2016Q2")
```

```{r}
cbind(rt1, rt2, union = TRUE)
cbind(rt1, rt2, union = FALSE)
```
For `union = TRUE` the result is padded with NA's if needed.

```{r echo = FALSE, results = "hide"}
data <- matrix(1:8, ncol = 2)
rt1 <- regts(data, start = "2016", names = c("a", "b"))
rt2 <- regts(data, start = "2016", names = c("d", "c"))
t1  <- ts(data, start = c(2016), names = c("a", "b"))
t2  <- ts(data, start = c(2016), names = c("d", "c"))

cbind(rt1,rt2)
ts.union(t1, t2)
cbind(t1,t2)

```

The `suffixes` argument is obligatory if the joined objects have overlapping 
column names:

```{r}
rt1 <- regts(data1, start = "2016Q1", names = c("b", "a", "c"))
rt2 <- regts(data, start = "2016Q1", names = c("d", "b"))

cbind(rt1, rt2, suffixes = c("_1","_2"))
```

The implementation of `cbind.regts` is also different from function `cbind.ts` 
(which is an alias for `ts.union`) because of the fact that available column 
names are always preserved.


# Multiple or chain calculations
Sometimes you have a 'chain' of calculations, where the left hand side of an 
equation is used in the right hand side of a following equation. For example:

```{r}
a <- regts(1:4, start = "2010Q2")
b <- a + 1
c <- b / a
d <- lag(a, -1)
cbind(a, b, c, d)
```
The result is a multivariate `regts`.

The code is less transparent when the chain is evaluated using a multivariate 
timeseries: 

```{r}
xts <- regts(data, start = "2010Q2", names = c("a", "x"))
xts[, "b"] <- xts[, "a"] + 1
xts[, "c"] <- xts[, "b"] / xts[, "a"]
xts["2010Q3/2011Q2", "d"] <- lag( xts[, "a"], -1)
xts
```
Note that when timeseries `d` is created you also have to select the lagged 
period. Otherwise the `xts` period is used. 
The reason is that in an assignment the period is *not* aligned.

In this case another method can be preferable. First convert the multivariate 
regts to a list of univariate timeseries with the `as.list` function. Then 
apply the `within` function. 

```{r}
xts <- regts(data, start = "2010Q2", names = c("a", "x"))
list <- as.list(xts)
list2 <- within(list, {
    b <- a + 1
    c <- b / a
    d <- lag(a, -1)
})
```

The result is a list. The timeseries in this list can be combined with a 
combination of functions `cbind` and `do.call`. Note the reverse ordering of 
the columns.

```{r}
do.call(cbind, list2)
```

The elements in the result list all have type `regts`, so the result is a 
`multivariate regts`. 

If another numeric or logical type is added to this list, it is also converted 
to a regts by `cbind`:

```{r}
list3 <- within(list2, {
    e <- 0
    f <- TRUE
})
do.call(cbind, list3)
```
\longerpage[1]
The elements `e` and `f` are repeated for the whole period and the value `TRUE` is coerced to `numeric`. ^[You could also add a character variable, i.e. g <- "a". Now the result will remain a `regts`, but all elements of the timeseries will be coerced to character data, which is probably not what you want.]


# Differences between multivariate timeseries
Comparing two multivariate timeseries with a large number of columns can be quiet tedious, therefore function `tsdif` is created. It compares two multivariate timeseries objects which must have the same frequency.
The function calculates differences between columns with the same name, they do not have to be in the same order.
The actual function used to compute the differences can be specified, by default normal differences are computed.
Also argument `tol` can be specified: all differences smaller than `tol` will be ignored. By default `tol` is 0.


```{r}
rt1 <- regts(matrix(1:12, ncol = 3), start = "2016Q1", names = c("a", "b", "c"))
# create timeseries with slight differences, larger and smaller than the tolerance factor 
rt2 <- rt1
rt2[ ,"a"] <- rt1[ ,"a"] + 0.01
rt2[ ,"b"] <- rt1[ ,"b"] + 1e-6
rt2
tsdif(rt1, rt2, tol = 1e-3)
``` 

The function shows a limited report of the result, but it's result is a list with several components. Some of them are shown in the next example.

```{r}
difvar <- tsdif(rt1, rt2, tol = 1e-3)
difvar$equal
difvar$difnames
difvar$tol
```

In this exampl `equal` is `FALSE`, because there are differences larger than the tolerance `tol`. The names of the common columns with differences larger than the tolerance appear in `difnames`. Component `dif` is a `regts` with the computed differences of these columns. If there are no differences `dif` becomes `NULL`. In this case the difference between columns `a` is equal for all quarters: 0.01. The tolerance argument `tol` is actually an input argument but added to the list of components for the sake of completeness.

In the previous example the two objects had the same column names. Now we look at an example where the column names are different. We create a new timeseries `rt3`, an extension of timeseries `rt1` with an extra column:

```{r}
rt3 <- rt1
rt3[, "d"] <- regts(9:12, start = "2016Q1")
tsdif(rt1, rt3)
tsdif(rt1, rt3)$missing_names1
```

The `missing_names1` component contains the column names in the second timeseries that are missing in the first timeseries, in this case variable `d`. There are no `missing_names2`.

```{r}
tsdif(rt1, rt3)$equal
tsdif(rt1, rt3)$dif
```

All computed differences are smaller than or equal to the tolerance factor, so component `dif` is `NULL`. Component `equal` is `FALSE`; it is only `TRUE` if both component `dif` is `NULL` and there are no missing names.

Let's compare two columns of regts objects `rt1` and `rt2`: columns `b` differ less than the tolerance factor and columns `c` are equal. Now the result is equal:

```{r}
dif_bc <- tsdif(rt1[, c("b","c")], rt2[, c("c","b")], tol = 1e-5)
dif_bc$equal
```

As you can see the ordering of the columns makes no difference.



# `period` and `period_range`\label{period}

When the same period is used several times, it is preferable to define a variable 
containing this period. This could be a textstring containing a period but 
package `regts` also defines special classes representing 
periods: the `period` class for a single period and the `period_range` 
class for a range of periods. With these classes is it possible to manipulate the
period or the period_range, as shown further on in this section. 

## `period`

A `period` object can be created with the `period` function. 

```{r}
prd1 <- period("2016Q4")
prd1
prd2 <- period("2015-2", frequency = 4)
prd2
```

In the last example the `frequency` has to be specified. `"2015-2"` is 
ambiguous. Here "2" denotes the second quarter but it could also be for instance 
a month indicator or a half year. The `frequency` argument is required if you 
want to define a period with a frequency other than 1, 4 or 12, since there is 
no special format for these frequencies.

Special functions have been designed for the `period` class e.g. to extract 
a subperiod or the year:

```{r}
get_subperiod(prd1)
get_year(prd2)
```

`period` objects can be used as input for the `start` and `end` arguments of 
the `regts` function.

```{r eval = TRUE}
ts    <- regts(1:10, start = prd1)
```

When printed, a `period` variable seems to be nothing more than a character 
string. With the `str` function we can show the internal representation of a 
`period` object:

```{r}
str(period("2016Q4"))
```

The internal representation of period `2016Q4` is the number of quarters since 
the beginning of the Christian era, starting with 0 (`8067 = 2016 * 4 + 3`).

## `period_range`
There is also a `period_range`, an object that represents an interval of 
periods. Such a range can be created in the following ways:

```{r}
range <- period_range("2014Q4", "2017Q4")
range
period_range("2014Q4/2017Q4")
```

The lower or upper bound of the range may be undetermined:

```{r}
period_range("2017Q1", NULL)      # No upper bound
```

A `period_range` variable can be used in the `regts` function, specifying the 
`period` argument:
 
```{r}
range1 <- period_range("2016Q1", "2016Q3")
rts <- regts(matrix(1:18, ncol = 3), period = range1, names = c("a", "b", "c"))
rts
```
A `period_range` variable can also be obtained from a timeseries:

```{r}
get_period_range(rts)
```

The length of a `period_range` can be determined by the `nperiod` function:

```{r}
nperiod(range1)
```
Functions `start_period` and `end_period` are used to retrieve the first and 
last period in a `period_range`:

```{r}
start_period(range1)
end_period(range1)
range2 <- period_range(start_period(range1)+1, end_period(range1)-1)
ts <- regts(data, period = range2)
```

## Shifting period(s)\label{shifting}
With operators `+` and `-` the period can be shifted. Some examples for `period`: 

```{r}
period("2016Q4") + 1
p1 <- period("2015Q1")
p1-5
```

And for a `period_range`:

```{r}
period_range("2016Q4", "2017Q4") + 1
period_range(p1, p1+4)            # a `period` as input
```

Note that one of the operands must be numeric^[Command `period("2015Q1") + period("2015Q2")` results in an error message: 'Arithmetic operation on two 
periods is not allowed.'].


# Selecting and updating
In section \ref{periodselection} we have shown how periods can be selected 
with a string. A `period` can also be used to select or update a period of a 
timeseries object.  Consider the following (previously defined) timeseries:

```{r}
rts
```
Use a `period` to select and update the timeseries.
```{r}
prd1 <- period("2016Q2")
rts[prd1] 
rts[prd1] <- 3
rts
```

A `period_range` can be used to select and update multiple periods:

```{r}
# define a period range and make selections
range <- period_range("2016Q2", "2016Q3")
var <- rts[range]     
rts[range, c("a", "b")]
# define another period range and create a new timeseries column
smpl <- period_range("2016Q1", "2017Q1")
rts[smpl, "xx"] <- 2                
rts
```

Note that because timeseries `xx` is created with an extended period, all 
timeseries in (multivariate regts) object `rts` are extended.

&nbsp;  
**Update function**

It is also possible to use a multivariate timeseries to update another
multivariate timeseries. The two timeseries must have the same frequency
but their period ranges may be different (non overlapping periods will be set to
NA). For the result timeseries the union of the ranges is taken. There are 
three different methods to update the timeseries depending on how to deal with
NA values. Possible methods for this function `update_ts` are:

* `upd` use all of the second timeseries to update the first timeseries

* `updna` only update NA values in the first timeseries

* `updval` only use valid values in the second timeseries to update the first
timeseries

Of course only the common columns in both timeseries are updated. Extra columns
in the second timeseries aer added to the result, depending on the method and 
the content of that columns.

Some examples:

```{r}
series1 <- regts(matrix(rep(1,6), ncol = 3), start = "2017Q1", names = c("a","b","c"))
series2 <- regts(matrix(rep(2,4), ncol = 2), start = "2017Q1", names = c("a","d"))
update_ts(series1, series2, method = "upd")
series1[, "a"] <- NA
series2[, "d"] <- NA
update_ts(series1, series2, method = "updna")
update_ts(series1, series2, method = "updval")
```
In the last result variable "d" is not included because it has no valid values.




# Conversion between `data frame` and `regts` \label{dataframe}

It is possible to use a (part of a) data frame as input data for a `regts`

```{r}
df  <- data.frame(a = 1:3, b = 4:6, c = 7:9)
ts <- regts(df, start = "2017Q1")             # create a multivariate regts
ts
```

The function `regts` uses the `data.matrix` function in the `base` package to 
convert a data frame to a numeric matrix. By default the column names of the 
data frame are used for the timeseries names.

As with matrix input, it is also possible to specify names or add labels. This 
is already described in section \ref{multits}. Labeling has been discussed in 
section \ref{labels}.

In the previous example we had to specify the period of the result timeseries.
Sometimes the period is already contained in the data frame, e.g. in the 
row names. Consider the following data frame:

```{r}
df <- data.frame(a = 1:3, b = 4:6)  # data frame with period in row names
rownames(df) <- c("2015Q3", "2015Q4", "2016Q1")
df
```

The function `as.regts` can be used to convert a `data.frame` to a `regts`:

```{r}
ts <- as.regts(df)
ts
```

Function `as.regts` assumes that the period is stored in the row names.
If the periods are in a column of the data frame, then the `time_column` argument 
can be used. You can specify the column name or number of the data frame in which 
the period is stored. Specifying 0 means the period is contained in the row names 
of the data frame.

```{r}
# data frame with period in column 'periods'
df2 <- data.frame(periods = c("2015Q3", "2015Q4", "2016Q1"), a = 1:3, b = 4:6)
ts2 <- as.regts(df2, time_column = "periods")
ts2
```

Function `as.regts` uses the function `period` to convert the 'period text' 
(like `2015Q3`) to a `period`.
This function can handle several period formats: `2016`, `2016Q4`, `2016.4q`,
`2016/4Q`, `2016-4q`, `2016_q4`, ...
where no distinction is made between 'q' and 'Q'.

If the period is ambiguous, use the frequency argument:
```{r}
# data frame with indicisive period in row names
df <- data.frame(a = 1:3, b = 4:6)
rownames(df) <- c("2015-3", "2015-4", "2016-1")
ts <- as.regts(df, frequency = 4)
```

If the data frame contains periods in another, non standard, format, it is 
possible to specify your own function for the conversion of a text to a 
`period`. Use the `fun` argument, if necessary with extra arguments.

The reverse conversion from a `regts` to a `data frame` can be achieved with 
function `as.data.frame`. Therefore the `as.data.frame` function has been 
extended for `regts` types:

```{r}
as.data.frame(ts)
```
\longerpage[1]
The results look similar to `ts`. The timeseries names have become the data frame column names and the periods show up in the row names. Of course the `classes` 
are different.


# Aggregate functions

## Function `aggregate`

The function `aggregate` can be used to convert a timeseries to a lower frequency. 
For example to convert a monthly timeseries to a quarterly timeseries, or a 
quarterly timeseries to a yearly timeseries.

An example with a monthly timeseries:

```{r}
regtm1 <- regts(1:24, start = "2016M1")
regtm1
aggregate(regtm1, FUN = mean, nfrequency = 4)
```

And another with a quarterly timeseries:
```{r}
regt1 <- regts(1:10, start = "2016Q1")
regt1
```
```{r results = "hide"}
aggregate(regt1, FUN = sum)
```

When the newlines are removed the result looks like this:

    regt1  Time Series: Start = 2016  End = 2017  Frequency = 1  [1] 10 26

The quarters in 2016 add up to 10, the quarters in 2017 to 26. Note that the 2 
quarters in 2018 are ignored. The `aggregate` function skips the incomplete 
years at the end.

A special situation occurs when for instance a quarterly timeseries doesn't 
start in the first quarter:
```{r}
regt2 <- regts(2:10, start = "2016Q2")
regt2
```
```{r results = "hide"}
aggregate(regt2, FUN = sum)
```
Now the result is:

    regt2  Time Series: Start = 2017     End = 2017     Frequency = 1  [1] 26

\longerpage[1]
The quarters in 2017 add up to 26 as before. But now the information for 2016 
is also not complete, and therefore ignored. This is what you would expect: 
for `regts` objects the `aggregate` function skips all years for which not all 
quarters are present.
 
Usually the `aggregate` function works the same for `regts` and `ts`, but in 
this case the result is very different. The same example with a `ts` timeseries:

```{r results = "hide"}
t2    <- ts(2:10, start = c(2016,2), frequency = 4)
aggregate(t2, FUN = sum)
```
The result is:

    t2     Time Series: Start = 2016.25  End = 2017.25  Frequency = 1  [1] 14 30
    
Now the first year (2016) is not ignored. This leads to a shifted result period 
(the start is `2016.25`) and shifted input (14 = 2 + 3 + 4 + 5), which makes the 
results peculiar.^[This problem does not occur when a quarterly timeseries ends 
before the last quarter, or before the end of the quarter in case of a monthly 
timeseries. Then the last year or quarter is ignored.].

So the function `aggregate` operates differently for a `regts` or a `ts` object, 
if the first period does not start at a subperiod for the new frequency.

## Aggregation for growth timeseries 
Another case is the treatment of timeseries that contain absolute, relative or 
percentage changes.
For this case the function `aggregate_gr` is developed with special aggregation algorithms, the so called 'cumulative growth'-methods.
A more detailed description of these methods can be found in the next subsection.
This function can be employed for both `regts` and `ts` timeseries. 

All methods convert input timeseries with high frequency to low frequency 
outputseries. There are four different type of methods for different types of 
input timeseries:

The `dif1s` and `dif1` methods assume that the input timeseries is a first 
difference of length 1 in the input frequency (for `dif1s` the input is also 
scaled) and calculate a first difference of length 1 in the output frequency. 

The `pct` and `rel` methods assume that the input timeseries is a one-period 
relative or percentage change and calculate the exact relative or percentage 
change for the output timeseries.

First a timeseries is created containing differences:
```{r}
xdif <- diff(regts(c(1,3,4,3,6,2,4,1,3,2), start = "2015Q4"))
xdif
```

Two examples of aggregation methods are shown:

```{r}
aggregate_gr(xdif, method = "dif1s", nfrequency = 1)  # result is a yearly timeseries
```
  
```{r}
aggregate_gr(xdif, method = "dif1")
```

## The cumulative growth methods 
The so called growth timeseries require special methods, a simple averaging of 
the subperiods in the high frequency observations will not return the correct 
answer. 
In this section a more detailed description of the four previously defined 
frequency conversion methods is given.

In advance some definitions are needed:  

We are temporally aggregating a timeseries $x$ with $n$ subperiods to a 
timeseries $X$ with a
lower frequency. In other words we want to convert a timeseries x with a high 
frequency
(monthly, quarterly) to a new timeseries with a lower frequency (quarterly, 
annual).

Let $x_{t,i}$   stand for the value of $x$ in subperiod $i$ of main period $t$.
The index $i$ takes on values in the range $1 .. n$.
We always interpret $x_{t,0}$ to mean $x_{t-1,n}$.
The time index $t$ refers to the periods in the time domain of $X$.
Many conversion methods only need the observations subperiod $i$ of main period $t$.
For example the \texttt{mean} method calculates $X_t$ as follows
\begin{displaymath}
X_t = \sum_{i=1}^{i=n} x_{t,i}/n
\end{displaymath}

### `dif1s` method {-} 
Define $x$ to be the first difference  of $z$ scaled to the output frequency.
Thus
\begin{displaymath}
 x_{t,i} = n ( z_{t,i} - z_{t,i-1} )
\end{displaymath}
We can also define $z_{t,i}$ in terms of $x$ as follows
\begin{eqnarray*}
z_{t,i} & = & z_{t,i-1} + x_{t,i}/n\\
        & = & z_{t-1,n} + \sum_{j=1}^{i} x_{t,j}/n
\end{eqnarray*}
Now define $Z_t$ as the level timeseries in time domain $t$ corresponding
to $z$
\begin{eqnarray*}
Z_t &=& \sum_{i=1}^{n} z_{t,i}\\
    &=& \sum_{i=1}^{n} z_{t-1,n} + \sum_{i=1}^{n} \sum_{j=1}^{i} x_{t,j}/n\\
    &=& \sum_{i=1}^{n} z_{t-2,n} + \sum_{i=1}^{n} \sum_{j=1}^{n} x_{t-1,j}/n + \sum_{i=1}^{n} \sum_{j=1}^{i} x_{t,j}/n
\end{eqnarray*}
Then $X$ in any period $t$ can be calculated from
\begin{displaymath}
X_t = Z_t - Z_{t-1}
\end{displaymath}
Since $Z_{t-1}$ can be written as
\begin{displaymath}
Z_{t-1} = \sum_{i=1}^{n} z_{t-2,n} + \sum_{i=1}^{n} \sum_{j=1}^{i} x_{t-1,j}/n\\
\end{displaymath}
it is easy to show that $X_t$ does not depend on $z_{t-2,n}$.
In any practical algorithm $z_{t-2,n}$ can be set to 0.

A compact equation for $X_t$ can be derived by substituting the equations for
$Z_t$ and $Z_{t-1}$ into the definition of $X_t$
\begin{displaymath}
X_t = \sum_{i=1}^n
        \left(
          \sum_{j=i+1}^n x_{t-1,j} + \sum_{j=1}^i x_{t,j}
        \right) / n
\end{displaymath}
This expression can be futher simplified by changing the order of summation.
For the first summation, we can write
\begin{displaymath}
 \sum_{i=1}^n  \sum_{j=i+1}^n x_{t-1,j} = \sum_{j=2}^n \sum_{i=1}^{j-1} x_{t-1,j}
                    = \sum_{j=2}^n  (j-1) x_{t-1,j}
\end{displaymath}
Similarly,
\begin{displaymath}
 \sum_{i=1}^n  \sum_{j=1}^i x_{t,j} = \sum_{j=1}^n  \sum_{i=j}^{n} x_{t,j} =
                             \sum_{j=1}^n  (n - j + 1) x_{t,j}
\end{displaymath}

The final equation is given by
\begin{displaymath}
X_t =  \left(  \sum_{j=2}^n  (j-1) x_{t-1,j} +  \sum_{j=1}^n  (n - j + 1) x_{t,j} \right) / n
\end{displaymath}


### `dif1` method {-}
Define $x$ to be the first difference  of $z$. Thus
\begin{displaymath}
 x_{t,i} = z_{t,i} - z_{t,i-1}
\end{displaymath}
We can also define $z_{t,i}$ in terms of $x$ as follows
\begin{eqnarray*}
z_{t,i} & = & z_{t,i-1} + x_{t,i}\\
        & = & z_{t-1,n} + \sum_{j=1}^{i} x_{t,j}
\end{eqnarray*}
Further derivations are analogous to the case for the \texttt{dif1s} method
described in the previous section.

### `rel` method {-}
Define $x$ to be the relative change in $z$. Thus
\begin{displaymath}
 x_{t,i} = (z_{t,i} - z_{t,i-1}) / z_{t,i-1}
\end{displaymath}
We can also define $z_{t,i}$ in terms of $x$ as follows
\begin{eqnarray*}
z_{t,i} & = & z_{t,i-1}(1 + x_{t,i})\\
        & = & z_{t-1,n}  \prod_{j=1}^{i}(1+ x_{t,j})\\
        & = & z_{t-2,n} \prod_{j=1}^{n}(1+ x_{t-1,j}) \prod_{j=1}^{i}(1+ x_{t,j})
\end{eqnarray*}
Now define $Z_t$ as the level timeseries in time domain $t$ corresponding
to $z$
\begin{eqnarray*}
Z_t &=& \sum_{i=1}^{n} z_{t,i}\\
    &=&  z_{t-1,n} \sum_{i=1}^{n} \prod_{j=1}^{i}(1+ x_{t,j})\\
    &=&  z_{t-2,n} \prod_{j=1}^{n}(1+ x_{t-1,j}) \sum_{i=1}^{n} \prod_{j=1}^{i}(1+ x_{t,j})
\end{eqnarray*}
Then $X$ in any period $t$ can be calculated from
\begin{displaymath}
X_t = Z_t / Z_{t-1} - 1
\end{displaymath}
Using the expression for $Z_{t-1}$
\begin{displaymath}
Z_{t-1} = z_{t-2,n}  \sum_{i=1}^{n} \prod_{j=1}^{i}(1+ x_{t-1,j})
\end{displaymath}
we obtain
\begin{displaymath}
X_t = \frac{\prod_{j=2}^{n}(1+ x_{t-1,j}) \sum_{i=1}^{n} \prod_{j=1}^{i}(1+ x_{t,j})}
{1 + \sum_{i=2}^{n} \prod_{j=2}^{i}(1+ x_{t-1,j})} - 1
\end{displaymath}

### `pct` method {-}
Define $x$ to be the percentage change in $z$. Thus
\begin{displaymath}
 x_{t,i} = 100 (z_{t,i} - z_{t,i-1}) / z_{t,i-1}
\end{displaymath}
We can also define $z_{t,i}$ in terms of $x$ as follows
\begin{eqnarray*}
z_{t,i} & = & z_{t,i-1}(1 + 0.01 x_{t,i})\\
        & = & z_{t-1,n} \prod_{j=1}^{i}(1+0.01 x_{t,j})
\end{eqnarray*}
Now define $Z_t$ as the level timeseries in time domain $t$ corresponding
to $z$
\begin{displaymath}
Z_t = \sum_{i=1}^{n} z_{t,i}
\end{displaymath}
Then $X$ in any period $t$ can be calculated from
\begin{displaymath}
X_t = 100(Z_t / Z_{t-1} -1)
\end{displaymath}
Further derivations are analogous to the case for the \texttt{dif1s} method
described in the previous section.

<!--
-->













