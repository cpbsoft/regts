#' Bind two or more timeseries
#'
#' Bind two or more time series objects with a common frequency.
#' By default, the period range of the result is the union of the period ranges
#' of the individual timeseries. The result is padded with \code{NA}s if
#' necessary. If argument \code{union} is false, then the period range
#' of the result is the intersection of the period ranges.
#'
#' @param  ... two or more univariate or multivariate time series,
#' or objects which can be coerced to time series
#' @param union if \code{TRUE}, then the period range of the result
#' is the union of the period ranges of the joined objects
#' (the result is padded with \code{NA}s if necessary). If \code{FALSE},
#' then the period range of the result is the intersection of the period ranges
#' of the joined objects.
#' @param suffixes Suffixes appended to the column names for overlapping
#' columns. This argument is obligatory if the timeseries have overlapping
#' column names
#' @seealso \code{\link{as.list.regts}}
#' @importFrom stats ts.union ts.intersect
#' @examples
#' a <- regts(1:5, start = "2011Q1")
#' b <- regts(matrix(11:15, nc = 1), start = "2011Q2")
#' cbind(a, b)
#' cbind(a, b, union = FALSE)
#' @export
cbind.regts <- function(..., union = TRUE, suffixes) {

    if (union) {
        ret <- ts.union(..., dframe = FALSE)
    } else {
        ret <- ts.intersect(..., dframe = FALSE)
    }

    if (!is.mts(ret)) {
        return (ret)
    }

    # The following code is to create column names for the result.
    # We do not like the column names created by ts.union and ts.intersect when
    # the arguments are multivariate timeseries with colnames,
    # therefore we create our own column names
    args <- list(...)
    cnames <- lapply(args, FUN = colnames)

    missing_colnames <- lapply(cnames, FUN = is.null)
    missing_colnames_vec <- unlist(missing_colnames)

    if (all(missing_colnames_vec) && !anyDuplicated(colnames(ret))) {
        # In this case the column names generated by ts.union and ts.intersect
        # are ok. All columns names are based on the names of the arguments,
        # and there are no duplicates. No further checking, which causes
        # extra cpu time, is required. This situation typically occurs
        # in calls such as do.call(cbind, as.list(regts1)).
        return (add_labels(as.regts(ret), args))
    }

    if (any(missing_colnames_vec)) {
        # create colnames for arguments without colnames.
        # this mechanism is the same as in ts.intersect and ts.union.
        ts_names <- get_ts_names(...)
        get_colnames <- function(i) {
            if (missing_colnames[[i]]) {
                nc <- NCOL(args[[i]])
                if (nc > 1) {
                    ret <- paste(ts_names[[i]], 1 : nc, sep = ".")
                } else {
                    ret <- ts_names[[i]]
                }
            } else {
                ret <- cnames[[i]]
            }
            return (ret)
        }
        cnames <- lapply(seq_along(args), FUN = get_colnames)
    } else {
        cnames <- unname(cnames)
    }

    cnames_unique <- lapply(cnames, FUN = unique)
    all_names <- unlist(cnames_unique)

    if (anyDuplicated(all_names)) {
        dupl <- duplicated(all_names)
        if (missing(suffixes)) {
            stop (paste0("Duplicate column names (",
                         paste(unique(all_names[dupl]), collapse = " "),
                         "). Specify argument suffixes."))
        } else if (length(suffixes) < length(args)) {
            stop (paste0("Length of argument suffixes is smaller than the",
                        " number of objects to be joined (", length(args),
                        ")."))
        }
        add_suffix <- lapply(cnames, function(x) x %in% all_names[dupl])
        fix_dupl <- function(i) {
            return (ifelse(add_suffix[[i]], paste0(cnames[[i]], suffixes[i]),
                           cnames[[i]]))
        }
        cnames  <- lapply(seq_along(args), fix_dupl)
    }

    cnames <- unlist(cnames)
    colnames(ret) <- cnames

    return (add_labels(as.regts(ret), args))
}

get_ts_names <- function(...) {
    # Returns the names of the ... arguments.
    # For example, if cbind was called as cbind(a, b), then this
    # function returns c("a", "b"). However, if cbind was called as
    # cbind(x = a, y= b), then the returned value if c("x", "y").
    # This code is based on the function stats:::.makeNamesTs.

    l <- as.list(substitute(list(...)))[-1L]
    nm <- names(l)
    fixup <- if (is.null(nm)) {
                seq_along(l)
             } else {
                 nm == ""
             }
    dep <- sapply(l[fixup], function(x) deparse(x)[1L])
    if (is.null(nm)) {
        return(dep)
    }
    if (any(fixup)) {
        nm[fixup] <- dep
    }
    return (nm)
}

add_labels <- function(x, args) {
    # Add ts_labels in args to x.

    if (all(unlist(lapply(args, FUN = function(x) is.null(ts_labels(x)))))) {
        # no arguments with labels
        return (x)
    }

    get_labels <- function(x) {
        # Returns the ts_labels of an R object, or a vector of empy
        # labels if x does not have labels
        lbls <- ts_labels(x)
        if (!is.null(lbls)) {
            return (lbls)
        } else {
            return (rep("", NCOL(x)))
        }
    }
    labels <- unname(unlist(lapply(args, FUN = get_labels)))
    ts_labels(x) <- labels
    return(x)
}

