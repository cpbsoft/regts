---
title: "Introduction to package regts"
author: "Rob van Harrevelt and Anita van der Roest"
date: '`r Sys.Date()`'
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
linkcolor: blue    
---
<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{Introduction package regts}
-->


```{r echo = FALSE, message = FALSE}
library(regts)
library(zoo)
data <- matrix(c(3,2,4,3,5,2,5,3), ncol = 2)
data1 <- matrix(c(1,3,2,6,4,8,3,0,9), ncol = 3)
input <- 1:10

# input/output chunks are separated
# R inputlines start with >, outputlines with nothing
knitr::opts_chunk$set(collapse = FALSE, comment = "", prompt = TRUE)

```

\newpage
# Introduction

When you start looking in R for timeseries you easily find several 
classes and packages, class `ts` from the `stats` package and `zoo` being mentioned most.
The function `ts` creates a regular timeseries object with class `ts`. This can be a univariate or multivariate object. It has a start, an end, a frequency and you can print, plot, extend and update it. But class `ts` has no easy way to deal with periods. 

<!--   
The zoo package provides infrastructure for regularly and irregularly spaced timeseries. Classes `yearmon` and `yearqtr` from zoo allow for more convenient computation with monthly and quarterly observations, respectively.
-->
Packages like `xts` and `zoo` (also for irregularly spaced timeseries) concentrate more on daily (or weekly) based data. 

We believe that we can add something to the existing structures.
We aim for a simple way to handle periods and concentrate on timeseries with annual, quarterly and monthly periods, like most economic data.  

`Regts` is a package defined for regular timeseries objects built on class `ts` but with easy features for selecting periods. 
The `regts` package defines a class `regts` that is an extension to the `ts` class.
Because of this the `regts` class benefits of all the functionality of `ts`.
The period handling is especially for monthly, quarterly and annual timeseries and is much easier than in the `ts` class.

Another extension in package `regts` is the use of labels, a description of the timeseries. Furthermore a special set of aggregation functions is added.

To use this package `regts` load it with:
```{r eval = FALSE}
library(regts)
```


# Creation regts

## Single timeseries
A single `regts` timeseries is created with the function `regts`. An example for a quarterly timeseries:

```{r echo = 1}
tq <- regts(1:10, start = "2016Q3")
```
with result:
```{r echo = FALSE}
tq
```

The period can also be a month, like "2016M3", or a year: 

```{r echo = 1}
ty <- regts(c(.11, .29, .18, .24), start = "2017")
```
```{r echo = FALSE}
ty
```
Printing a year timeseries looks different from quarterly timeseries output.

The `class` of `tq` and `ty` is `regts`, and because of the inheritance, also `ts`.
```{r}
class(tq)
```

The end period of the timeseries is based on the length of the input data.
If the input data is longer than you require you can make a selection with the `end` parameter:

```{r}
ts_data <- regts(input, start = "2016Q1", end = "2016Q4")
```

Sometimes the period is not decisive, then a frequency is needed:

```{r}
ts_data <- regts(input, start = "2016-1", end = "2017-1", frequency = 2)
```

Instead of parameters `start` and `end` you can also specify parameter `period`:
```{r}
ts_data <- regts(input, period = "2016Q1/2016Q4")
```
Input for this period may be a character string as shown above, but also a variable of type `regperiod_range`. This type will be explained in section [regperiod_range](#regperiod_range).

## Multiple timeseries
Sometimes it is more convenient to combine several timeseries in a single object: a multiple timeseries. 
Basic data for a multiple timeseries is a two-dimensional matrix with two or more columns. In fact a multiple `regts` is nothing more than a matrix with some extra facilities. All timeseries share the same period (the number of rows).

```{r}
rts <- regts(matrix(1:9, ncol = 3), start = "2016Q1")
```
The matrix may already have columnnames, if so they become the names of each of the timeseries. 
Otherwise the names can be given, these names represent the column names of the (multivariate) timeseries.

```{r}
rts <- regts(matrix(1:9, ncol = 3), start = "2016Q1", names = c("a", "b", "c"))
rts
```

Since timeseries rts is multiple, classes `mts` (the multiple `ts`) and `matrix` are applicable:

```{r}
class(rts)
```

If more documentation is needed for a timeseries than just the (short) name, optionally labels can be added
(see also section [labels](#labels)).


### Column selection and creation

Column selection is the same as with matrices. We get access to each single timeseries or to a subset of the original multiple timeseries:

```{r}
a1_ts <- rts[ , "a"]
ac_ts <- rts[ , c("a", "c")]
```

With the `regts` type we can also create new columns:

```{r echo = 1}
rts[, "x"] <- 2 * rts[, "a"]  # creating a new column "x"
rts
```
This is not possible for types `ts` and `matrix`.


### Selecting columns with a regular expression
The `regts` package contains a function `select_columns` to select columns of an R object with column names. Besides `regts` this can be a `matrix` or a `data.frame`.
The columns with names matching a given regular expression are selected.
A few examples:

```{r}
rts <- regts(matrix(1:8, ncol = 4), start = "2016Q1", names = c("a1", "b1", "a2", "b2"))
select_columns(rts, regex = "a.*")  # all columns with names starting with a
select_columns(rts, regex = ".+1")  # all columns with names ending with 1
```

The syntax of `regular expression` patterns is described in the R Documentation.
<!-- 
`Data` can be a vector, a matrix or inputdata. `Start` and `end` are `regperiods` or types that can be converted to a `regperiod`. 

`Frequency` only has to be specified if no period indicator is known from the `start` or `end` parameter. 


ts_data <- regts(matrix(1:8, ncol = 2), start = "2016Q1", end = "2016Q4",
                 names = c("a", "b"), labels = c("Series_a", "Series_b"))
ts_data
```
-->

## Matrices with one column
If a `regts` is created from a matrix with only one column, the timeseries is single. So there are two types of single timeseries: the one that is based on a vector and the one that is based on a one-column matrix: 

```{r}
ts      <- regts(1:8, start = "2016Q1")
ts_1col <- regts(matrix(1:8, ncol = 1), start = "2016Q1", names = "a")
```
They have identical output:
```{r, echo = FALSE }
ts
```
```{r, echo = FALSE }
ts_1col
```
and identical classes:

```{r, echo = FALSE}
class(ts_1col)
```
but the underlying data are different.

Another difference between the 'vector' version and the 'matrix-1-column' version is that the latter can have a column name, as you can see in the previous example. Single 'vector' timeseries never have a column name. In RStudio you can see the difference (the column name) with the `View` function.

A single 'matrix-1-column' timeseries arises too when a single column is selected from a multiple timeseries with the argument `drop = FALSE`. In this case the column name is preserved. If this argument is omitted (or `drop = TRUE` is used) a single 'vector' timeseries is created. A possible column name disapppears in this case. An example:  

```{r results = "hide"}
rts <- regts(matrix(1:8, ncol = 2), start = "2016Q1", names = c("a", "b"))

rts[ ,1, drop = FALSE] # result is a one-dimensional matrix with column name "a"
rts[ ,2]               # result is a vector, column name "b" is lost
```


# Period selection
Regts is specially designed for the selection of periods. Where for a `ts` timeseries you have to use the `window` function:

```{r}
ts1 <- ts(c(1,2,3,4,5,6,7,8), start=c(2016,1), end=c(2017,4), freq=4)

window(ts1, start = c(2016,4), end = c(2017,2))
```

with a `regts` you can select periods with the selection operator `[]`^[When applying period selection you can use both symbols: ' or ".]. Period selection is a form of subsetting. 

```{r echo = -1, results = "hide"}
ts <- regts(1:8, start = "2016Q1", end = "2017Q4")
ts["2016Q1/2017Q2"]
```
Besides a range you can also select one period:

```{r results = "hide"}
ts["2017Q1"]
```    
    
or a range with an open beginning or end:

```{r results = "hide"}
ts["/2017Q2"]
ts["2017Q1/"]
```

If a selection is specified with a period indicator outside the defined range, the timeseries is filled with NA values for that area:

```{r}
ts["/2018Q2"]
ts["2015Q3/"] 
```

Period selection can also be applied on the lefthandside of an assignment, in the target timeseries. The object must exist before applying selection.

```{r}
rts1 <- regts(1:8, start = "2010Q1", end = "2011Q4")
rts1["2011Q2"] <- 2
rts1["/2010Q3"] <- 99
rts1
```


```{r eval = FALSE, echo=FALSE}
# gives warning because rts5 doesn't exist
rts5["2011Q3"] <- 2 * rts1["2011Q3"]  
```

Period extensions (before and/or after) are dealt with automatically:
```{r}
rts1["2009Q1/2009Q2"] <- rts1["2010Q3/2010Q4"]
rts1
```
The missing quarters (2009Q3 and 2009Q4) are filled in with NA values.

## Period selection for multivariate regts

Selecting a period for a multivariate regts is quite similar. You can select one or more periods, or a combination of period(s) and columns:

```{r}
rts <- regts(matrix(1:12, ncol = 3), start = "2011Q1", names = c("a", "b", "c"))

rts["2011Q2", ]

rts["2011Q2"]     # the , is not necessary

rts["2011Q1/2012Q2", "c"]

rts["2011Q4/", c("a", "b")]
```

Selection in the target timeseries:

```{r echo = 1:3}
rts[, "x"] <- NA              # define an extra column
rts["2012Q1", ] <- 99         # period extending for all columns 
rts["2011", "x"] <- 1         # update all quarters in 2011 in column "x"
rts
```

All not defined elements become NA.

When the same period selection is used several times the `regts` package offers a nice solution: the `regperiod`. It will be described in the next section.

\newpage
# Regperiod and regperiod_range{#regperiod}

When you repeatedly use the same period, it is handy to define a variable containing this period. Besides periods in character strings it is also possible to use `regperiod` or `regperiod_range` variables as means of definition or selection.  

A `regperiod` variable can be created with the `regperiod` function. 

```{r}
prd1 <- regperiod("2016Q4")
prd2 <- regperiod("2015-2", frequency = 2)
```

In the second example the `frequency` has to be specified. "2015-2" is not decisive. The "2" can also be a quarter or a month indicator.

The result `regperiod` can become the input for the `start` and `end` parameters of the `regts` function.

```{r eval = TRUE}
first <- regperiod("2015Q1")
ts    <- regts(1:10, start = first)
```

Or you can use it as a way to select or update a part of a timeseries:
```{r}
var <- rts1[prd1] 
rts1[prd1] <- 3
```

And with  operators `+` and `-` simple arithmetic operations can be performed:

```{r}
prd3 <- prd2 + 1
prd3
prd2 - 5
```

A `regperiod` seems to be nothing more than a character string. With the `str` function we can show the real content of object prd1 :

```{r}
str(prd1)
```

The internal representation of period `2016Q4` is `2016 * 4 + 3 = 8067`^[This is the number of quarters since the beginning of the Christian era, starting with 0.].

## Regperiod_range{#regperiod_range}

Obviously there is also a `regperiod_range`, an object that represents an interval of `regperiod`. Such a range can be created in the following ways:

```{r}
range <- regperiod_range("2014Q4", "2017Q4")
range
```

The lower or upper bound of the range may also be undetermined:

```{r}
regperiod_range("2017Q1", NULL)   # No upperbound
```

Use a regperiod as basis and do some basic calculations ( only + and - are allowed):
```{r}
p1     <- regperiod("2015Q1")
regperiod_range(p1, p1+4)
range + 1
```

A `regperiod_range` variable can be used in the `regts` function, specifying the 'period' parameter:
 
```{r}
range1 <- regperiod_range("2016Q1", "2017Q4")
regts(matrix(1:12, ncol = 3), period = range1)
```

A `regperiod_range` has the same selecting and updating possibilities as  `regperiod`:

```{r}
range_2011 <- regperiod_range("2011Q1", "2011Q4")
var2011 <- rts[range_2011]
rts[range_2011, c("a", "b")]

smpl <- regperiod_range("2011Q1", "2012Q4")
rts[smpl, 'xx'] <- 2          # creating a new column "xx" for period smpl
rts
```

```{r echo = FALSE}
rtsx <- rts
```

Notice that because timeseries `xx` is created with an extended period, all timeseries in (multiple regts) variable rts are extended.

The length of the range may be obtained by using the `lensub` function:

```{r results = "hide"}
lensub(smpl)
```
Functions `start_period` and `end_period` are used to select the first and last period in a `regperiod_range`:

```{r}
start_period(range1)
end_period(range1)
ts <- regts(data, start = start_period(range1), end = end_period(range1))
```


# Data frame {#dataframe}
The data frame type in R is widely used and extensively documented elsewhere, so here we will only describe the use related to `regts` objects.

It is possible to use a (part of a) data frame as input data for a `regts`

```{r}
df  <- data.frame(a = 1:3, b = 4:6, c = 7:9)

ts1 <- regts(df, start = "2017Q1")       # create a multivariate regts
ts2 <- regts(df[, 2], start = "2017Q2")  # create a univariate regts
```
with results:

[//]: # for literary text put >2 spaces in the beginning of the line:

    df                  ts1                   ts2
      a b c                     a b c           
    1 1 4 7             2017 Q1 1 4 7              Qtr2 Qtr3 Qtr4
    2 2 5 8             2017 Q2 2 5 8         2017    4    5    6
    3 3 6 9             2017 Q3 3 6 9


The function `regts` uses the `data.matrix` function in the `base` package to convert a data frame to a numeric matrix. By default the df colnames are used for the timeseries names. Names can also be given:

```{r echo = 1}
ts <- regts(df, start = "2017Q1", names = c("v1", "v2", "v3"))
ts
```

It is also possible to add labels. They are discussed in section [labels](#labels).

## Conversion between data frame and regts
There is also the possibility of conversion.
Two conversion functions are used to easily convert a `data frame` to a `regts` and vice versa: `as.regts` and `as.data.frame`, both S3 generics. 

When converting a `data.frame` to a `regts` the function `as.regts` assumes that the period is stored in the row names:

```{r}
# data frame with period in row names
df <- data.frame(a = 1:3)
rownames(df) <- c("2015Q3", "2015Q4", "2016Q1")
as.regts(df)
```

The period format can be indecisive. In that case use the `frequency` parameter:

```{r}
rownames(df) <- c("2015 3", "2015 4", "2016 1")
ts <- as.regts(df, frequency = 4)
```

If the period is not available in the row names, the `time_column` parameter can be used. You can specify the column name(s) or number(s) of the data frame in which the period is stored. Specifying 0 means the period is contained in the row names of the data frame.

```{r}
# data frame with period in column 'periods'
df2 <- data.frame(periods = c("2015Q3", "2015Q4", "2016Q1"),  a = 1:3)
ts <- as.regts(df2, time_column = "periods")
```

Function `as.regts` uses the function `regperiod` to convert the 'textperiods' (like "2015Q3") to a regperiod.
This function can handle several period formats: "2016", "2016Q4", "2016.4q", "2016/4q", "2016-4q", "2016_q4", ...

When converting non standard periods in the data frame (no `regperiod` like objects), it is possible to specify your own function. Use the `fun` parameter, if necessary with extra arguments.

The `as.data.frame` function is extended for `regts` types:
```{r}
ts  <- regts(matrix(1:6, ncol = 2), start = "2017Q1", names = c("a","b"))
df  <- as.data.frame(ts)
```

    ts                       df                   
            a b                      a b            
    2017 Q1 1 4              2017 Q1 1 4               
    2017 Q2 2 5              2017 Q2 2 5          
    2017 Q3 3 6              2017 Q3 3 6 


The results look similar. The timeseries names become the data frame column names. The periods show up in the row names.


## Read timeseries from file

When you want to read timeseries data from a file it is best to use the `data.frame` class as a means to do so.

There are several ways to read a data frame from a file, like a

* `csv-file`: `read.csv` in package `utils` (installed by default) or `fread` in package `data.table`
* `xls and xlsx-file`: `read.excel` in package `readxl` 
* `.Rdata` file (default workspace in R): `load` (i.e. load("input.Rdata"))

Read information from a `csv-file`. Use `stringsAsFactors = FALSE` to prevent that character data (such as variablenames) is converted to factors.

```{r, echo = 1:2}
df <- read.csv("test.csv", stringsAsFactors = FALSE)

df
```

After reading, convert the data frame with the `as.regts` function.
Since the period is to be found in the first column, we employ the `time_column` parameter.

```{r, echo = 1:2}
series <- as.regts(df, time_column = 1)

series
```

Sometimes the data frame obtained is transposed, e.g. periods in the first row and column names in the first column.
When reading the file no check must be performed on the names, since they are periods, and therefore no valid names. (Valid names should start with [a-z].) To avoid this check use parameter `check.names`: 

```{r, echo = -3}
dft <- read.csv("transpose.csv", check.names = FALSE)

dft
```

For creating a 'normal' data frame use the `transpose_df` function.
With the `colname_column` parameter it is possible to give the name or index of the column that will be used as column names. By default the `row names` of the original data frame are used. 

```{r, echo = 1:2}
df <- transpose_df(dft, colname_column = 1)

df
```

After this the dataframe can be converted to a `regts` as usual.

Notice that not all files will have a straightforward content. Possibly there are comments, extra rows or columns or redundant cells in the file.
We aim to transform the data frame read to a standard format with the variablenames in the column names and the period in the row names. Use (negative) selection of rows and/or columns to get rid of unwanted information and the function `transpose_df` in case of a transposed file. The `as.character` function can be useful when creating row or column names. The result should look something like the data frame printed above. 
Next the standardized data frame can easily be converted to a regts.

## Write timeseries via data frame 
When `regts` timeseries data have to be stored on file or dataset, first convert the data using the `as.data.frame` function. The period and names of the `regts` become automatically the `rownames` and `colnames` of the `data.frame`.
Then use one of the available methods to save a data frame to file: `Write.csv` in package `utils` of `save` from the `base` package (both are installed by default).

```{r}
rts <- regts(data, start = "2016Q1", names = c("a","b"))
df <- as.data.frame(rts)

write.csv(df, "result.csv")
save(df, file = "output.Rdata")
```

You may want to write the data in transposed form:

```{r}
df <- as.data.frame(rts)
dft <- transpose_df(df)
dft

write.csv(dft, "result_transposed.csv")
```

# Operators and functions for regts
Since the `regts` class is an extension of the `ts` class all functionality from this class is available.
All arithmetic (`+`, `-`, `*`, `/`, `^`, `%%`, `%/%`), logical (`&&`, `||`, `!`), relational (`==`, `!=`, `<`, `<=`, `>`, `>=`) and subsetting (`[]`) operators applicable for a `ts` variable, can be used for a `regts` timeseries. Some examples:

```{r}
tx <- regts(1:10, start = "2017Q1")

# operators
ty    <- 2*tx + 1
tpyth <- tx^2 + ty^2   
modulo <- tx %% 2
tlog  <- tx < ty && ty > 1
number <- tx["2017Q2"]

```
When a binary arithmetic operator is used on two or more timeseries, the intersection of the periods is taken:

```{r}
tx <- regts(1:6, start = "2016Q1")
ty <- regts(1:6, start = "2017Q1")
tx + ty
```

You can use all functions applicable to a `ts` class timeseries. Some examples:
```{r, eval = FALSE}
tsin <- sin(tx)
tlog <- log(tx)
diff(tx)
plot(tx)
```


## Binding timeseries
As we have seen all functions that are available for `ts` are also available for `regts`. The `cbind` function (an S3 generic function) is one of them: it binds two or more objects with a common frequency. With the `cbind` function it is easy to combine several `univariate regts` to a `multivariate regts` or a combination of univariate and multivariate regts to a new multivariate regts. 

Yet the extension for `regts` has special features: arguments `union` and `suffixes`. 

The argument `union` effects the period range. With `union = TRUE` the union of the period ranges of the joined objects is taken, otherwise it is the `intersection`. An example:

```{r}
rt1 <- regts(1:4, start = "2016Q1")
rt2 <- regts(1:4, start = "2016Q2")

cbind(rt1, rt2, union = TRUE)

cbind(rt1, rt2, union = FALSE)
```
For `union = TRUE` the result is padded with NA's if needed.

```{r echo = FALSE, results = "hide"}
data <- matrix(1:8, ncol = 2)
rt1 <- regts(data, start = "2016", names = c("a", "b"))
rt2 <- regts(data, start = "2016", names = c("d", "c"))
t1  <- ts(data, start = c(2016), names = c("a", "b"))
t2  <- ts(data, start = c(2016), names = c("d", "c"))

cbind(rt1,rt2)
ts.union(t1, t2)
cbind(t1,t2)

```

The `suffixes` argument is obligatory if the joined objects have overlapping column names:

```{r}
rt1 <- regts(data1, start = "2016Q1", names = c("b", "a", "c"))
rt2 <- regts(data, start = "2016Q1", names = c("d", "b"))

cbind(rt1, rt2, suffixes = c("_1","_2"))
```

The implementation of `cbind.regts` is also different from function `cbind.ts` (which is an alias for `ts.union`) because of the fact that available column names are always preserved!

# Multiple or chain calculations
Sometimes you have a 'chain' of calculations that you want to combine. This can be done in the following way:

```{r}
a <- regts(1:4, start = "2010Q2")
b <- a + 1
c <- b / a
d <- lag(a, -1)
cbind(a, b, c, d)
```
The result is a multivariate regts.

When the basic timeseries is already multivariate this example turns into more inconvenient code: 

```{r}
xts <- regts(data, start = "2010Q2", names = c("a", "x"))
xts[, "b"] <- xts[, "a"] + 1
xts[, "c"] <- xts[, "b"] / xts[, "a"]
xts["2010Q3/2011Q2", "d"] <- lag( xts[, "a"], -1)
xts
```
Note that when creating timeseries `d` you also have to define the lagged period. Otherwise the `xts` period is used. 
The fact is that in an assignment the period is *not* aligned.

In this case another method can be preferable. First convert the multivariate regts to a list of univariate timeseries with the `as.list` function. Then apply the `within` function. 

```{r}
xts <- regts(data, start = "2010Q2", names = c("a", "x"))
list <- as.list(xts)
list2 <- within(list, {
    b <- a + 1
    c <- b / a
    d <- lag(a, -1)
})
```

The result is a list. The timeseries in this list can be combined with a combination of functions `cbind` and `do.call` ^[Notice the ordering of the columns: the columnnames are in reversed order!]:

```{r}
rts2 <- do.call(cbind, list2)
rts2 
```

The elements in the result list all have type `regts`, so the result is a `multivariate regts`. 

If another numeric or logical type is included in this list, it is also converted to a regts:

```{r}
# extend list2
list3 <- within(list2, {
    e <- 0
    f <- TRUE
})
rts3 <- do.call(cbind, list3)
rts3
```

The elements `e` and `f` are extended for the whole period and the value `TRUE` is transformed to `numeric`. ^[You could also add a variable character variable, i.e. g <- "a". Now the result variable will remain a `regts` but all elements of the timeseries will be converted to character data, which is probably not what you want!]

# Labels {#labels}
`Regts` timeseries are equipped with a label, a way to document each specific timeseries. Labels can be defined when creating the series and they are preserved in most timeseries functions.

```{r}
t1 <- regts(data1, start = "2017Q1", names = c("child", "adult", "senior"),
      labels = c("Age 0-17", "Age 18-65", "Age 65+"))
t1
```

As you see the labels are not shown automatically when printing the timeseries.
With the `View` function in RStudio you can view timeseries and its labels. The result looks like this:

              child       adult       senior
           Age 0-17   Age 18-65      Age 65+
    2017Q1        1           6            3
    2017Q2        3           4            0
    2017Q3        2           8            9

The labels can also be retrieved with the `ts_labels` function:

```{r}
ts_labels(t1)
```

In combination with the `<-` operator, the `ts_labels` command can be used to set labels to or remove labels from an existing `regts`:

```{r}
tx <- regts(data, start = "2017Q1")
ts_labels(tx) <- c("Trans X", "Label X")
ts_labels(tx)
ts_labels(tx) <- NULL       # remove all labels 
ts_labels(tx)
```

For updating one or more timeseries labels in a multivariate regts object, the function `update_ts_labels` is provided:

```{r eval = TRUE}
t1_update <- update_ts_labels(t1, labels = list(adult = "Age 18-67", senior = "Age 67+"))
```
```{r echo = FALSE}
ts_labels(t1_update)
```
Parameter `Labels` is a named list with the column names as names and the labels as values. 

## Labels when converting regts to dataframe and vice versa

When converting a regts with labels to a data frame the labels are preserved. You can view them with the `View` function in Rstudio or the `label` function in the `Hmisc` package:

```{r}
df <- as.data.frame(t1_update)
label(df)
```
The `label` function can be used to get or set labels in R objects other than `regts`.

```{r}
label(df) <- list(child = "Age under 18", adult = "Age between 18 and 67", senior = "Age above 67")
```

When a data frame with labels is converted to a multivariate regts you can see the labels as usual employing the `ts_labels` function:

```{r}
tt <- as.regts(df)
ts_labels(tt)
```

So the `ts_labels` function is used for collecting and assigning labels in `regts` objects. Otherwise employ the `label` function from the `Hmisc` package. 

## Labels when transposing a data frame

When transposing a data frame containing labels, which has its variables ordered columnwise, the labels will be set in the first column in the result data frame:

```{r}
dft <- transpose_df(df)
dft
```

When transposing a data frame which has a column with labels (the variables are ordered rowwise) you can specify this column with the `label_column` parameter of the `transpose_df` function:

```{r}
df2 <- transpose_df(dft, label_column = "labels")
df2
label(df2)
```
By default no labels are created.

## Labels in files
When you want to extract label information from a file, read the file in a data frame and select the row or column involved. Then assign the information to a variable. If necessary use the `as.character` function. 

```{r}
dfl <- read.csv("tstlabel.csv", stringsAsFactors = FALSE)
labels <- as.character(dfl[2, ]) # label information in 2nd row
```
With the `ts_labels` function it is possible to combine the labels with the corresponding (multivariate) timeseries.

It is also possible to write timeseries to a file together with its label information. The easiest way is to create a transposed data frame with labels. Since labels are preserved in most functions this is not a problem: 

````{r}
ts_data <- regts(matrix(1:8, ncol = 2), start = "2016Q1", end = "2016Q4",
                 names = c("a", "b"), labels = c("Series_a", "Series_b"))
df  <- as.data.frame(ts_data)
dft <- transpose_df(df)
dft
```

When writing this data frame to file, the labels are written along. 


# Differences between multivariate timeseries
It can be quiet tedious to compare two multivariate timeseries with different columns, especially when they have a number of columns. You have to check which columns are common and after that the periods and contents of the common columns must be compared.

The function `tsdif` is specially designed to compare two multivariate timeseries objects with the same frequency. Absolute and relative differences between the common columns can be calculated with a tolerance factor. By default the absolute differences are calculated:

```{r}
rt1 <- regts(data1, start = "2016Q1", names = c("b", "a", "c"))
rt2 <- regts(data, start = "2016Q1", names = c("d", "b"))
diflist <- tsdif(rt1, rt2, tol = 1e-3)
``` 

The result is a list with components, e.g. the tolerance parameter (`tol`) and the actual result which is TRUE or FALSE (`equal`). In the `missing_names` variables the not common columns appear.
The names of the common columns with differences larger than `tol` appear in `difnames`. Component `dif` is a `regts` with the computed differences of these columns. If there are no differences `dif` becomes `NULL`.

```{r echo = FALSE}
diflist
``` 

The `equal` component, in this case `diflist$equal`, is only TRUE if the two objects have the same column names (there must be no missing names!) and if all  differences are smaller than or equal to the tolerance factor.

# Aggregate functions
Normal use of the aggregate function of `ts` works fine for both `ts` and `regts`:
```{r results = "hide"}
regt1 <- regts(1:10, start = "2016Q1")
t1    <- ts(1:10, start = c(2016,1), frequency = 4)

aggregate(regt1, FUN = sum, nfrequency = 1)
aggregate(t1,    FUN = sum, nfrequency = 1)
```

The compressed results are: 

```{r eval = FALSE}
#regt1  Time Series: Start = 2016  End = 2017  Frequency = 1  [1] 10 26
#t1     Time Series: Start = 2016  End = 2017  Frequency = 1  [1] 10 26
```

A problem arises when a quarterly timeseries doesn't start in the first quarter.

```{r results = "hide"}
regt2 <- regts(2:10, start = "2016Q2")
t2    <- ts(2:10, start = c(2016,2), frequency = 4)

aggregate(regt2, FUN = sum, nfrequency = 1)
aggregate(t2,    FUN = sum, nfrequency = 1)
```

Now the results are different:

```{r eval = FALSE}
#regt2  Time Series: Start = 2017     End = 2017     Frequency = 1  [1] 26
#t2     Time Series: Start = 2016.25  End = 2017.25  Frequency = 1  [1] 14 30
```
Because of the shifted period in variable `t2`, it is obvious something is wrong,
but the results are peculiar and not correct. For a `regts` timeseries this (known) bug is mended and incomplete years are ignored.



## Special aggregation
For timeseries which contain for instance growth rates (absolute or relative), aggregation to a lower frequency takes special steps. A simple averaging of n high frequency observations will not return the correct answer.

For this case special aggregation algorithms are developed, the so called "cgrx"-methods. All methods convert input timeseries with high frequency to low frequency outputseries. The type of method depends on the input:

* `cgr` : input is a first difference scaled to the output frequency (an annualised quarterly first difference), output is a first difference
* `cgrs`: input and output are first differences
* `cgru`: input and output are relative changes
* `cgrc`: input and output are percentage changes

The `cgr` and `cgrs` methods assume that the input timeseries is a first difference of length 1 in the inputfrequency and calculate a first difference of length 1 in the outputfrequency. It can also be used for relative changes that
are small but this will not give exact results for very large numbers. 

The `cgru` and `cgrc` methods assume that the input timeseries is a one-period relative or percentage change and calculate the exact relative or percentage change for the output timeseries.

Some examples:
```{r eval = FALSE}
aggregate_gr(xdif, method = "cgr", nfrequency = 1)
aggregate_gr(xdif, method = "cgrs")
```

The next sections describe the transformations required for these four
frequency conversion methods.

### CGR method
Define $x$ to be the first difference  of $z$ scaled to the output frequency.
Thus
\begin{displaymath}
 x_{t,i} = n ( z_{t,i} - z_{t,i-1} )
\end{displaymath}
We can also define $z_{t,i}$ in terms of $x$ as follows
\begin{eqnarray*}
z_{t,i} & = & z_{t,i-1} + x_{t,i}/n\\
        & = & z_{t-1,n} + \sum_{j=1}^{i} x_{t,j}/n
\end{eqnarray*}
Now define $Z_t$ as the level timeseries in time domain $t$ corresponding
to $z$
\begin{eqnarray*}
Z_t &=& \sum_{i=1}^{n} z_{t,i}\\
    &=& \sum_{i=1}^{n} z_{t-1,n} + \sum_{i=1}^{n} \sum_{j=1}^{i} x_{t,j}/n\\
    &=& \sum_{i=1}^{n} z_{t-2,n} + \sum_{i=1}^{n} \sum_{j=1}^{n} x_{t-1,j}/n + \sum_{i=1}^{n} \sum_{j=1}^{i} x_{t,j}/n
\end{eqnarray*}
Then $X$ in any period $t$ can be calculated from
\begin{displaymath}
X_t = Z_t - Z_{t-1}
\end{displaymath}
Since $Z_{t-1}$ can be written as
\begin{displaymath}
Z_{t-1} = \sum_{i=1}^{n} z_{t-2,n} + \sum_{i=1}^{n} \sum_{j=1}^{i} x_{t-1,j}/n\\
\end{displaymath}
it is easy to show that $X_t$ does not depend on $z_{t-2,n}$.
In any practical algorithm $z_{t-2,n}$ can be set to 0.

A compact equation for $X_t$ can be derived by substituting the equations for
$Z_t$ and $Z_{t-1}$ into the definition of $X_t$
\begin{displaymath}
X_t = \sum_{i=1}^n
        \left(
          \sum_{j=i+1}^n x_{t-1,j} + \sum_{j=1}^n x_{t-1,j+n}
        \right) / n
\end{displaymath}
where $x_{t,j} = x_{t-1,j+n}$.
By changing indices in the two inner summations this can be simplified considerably.
Set $j=i+k$ in the first inner sum and $j=i+k-n$ in the second and after some
rearrangement we get
\begin{displaymath}
X_t = \sum_{i=1}^n \sum_{k=1}^n x_{t-1,i+k} / n
\end{displaymath}


### CGRS method
Define $x$ to be the first difference  of $z$. Thus
\begin{displaymath}
 x_{t,i} = z_{t,i} - z_{t,i-1}
\end{displaymath}
We can also define $z_{t,i}$ in terms of $x$ as follows
\begin{eqnarray*}
z_{t,i} & = & z_{t,i-1} + x_{t,i}\\
        & = & z_{t-1,n} + \sum_{j=1}^{i} x_{t,j}
\end{eqnarray*}
Further derivations are analogous to the case for the \texttt{cgr} method
described in the previous section.

### CGRU method
Define $x$ to be the relative change in $z$. Thus
\begin{displaymath}
 x_{t,i} = (z_{t,i} - z_{t,i-1}) / z_{t,i-1}
\end{displaymath}
We can also define $z_{t,i}$ in terms of $x$ as follows
\begin{eqnarray*}
z_{t,i} & = & z_{t,i-1}(1 + x_{t,i})\\
        & = & z_{t-1,n}  \prod_{j=1}^{i}(1+ x_{t,j})\\
        & = & z_{t-2,n} \prod_{j=1}^{n}(1+ x_{t-1,j}) \prod_{j=1}^{i}(1+ x_{t,j})
\end{eqnarray*}
Now define $Z_t$ as the level timeseries in time domain $t$ corresponding
to $z$
\begin{eqnarray*}
Z_t &=& \sum_{i=1}^{n} z_{t,i}\\
    &=&  z_{t-1,n} \sum_{i=1}^{n} \prod_{j=1}^{i}(1+ x_{t,j})\\
    &=&  z_{t-2,n} \prod_{j=1}^{n}(1+ x_{t-1,j}) \sum_{i=1}^{n} \prod_{j=1}^{i}(1+ x_{t,j})
\end{eqnarray*}
Then $X$ in any period $t$ can be calculated from
\begin{displaymath}
X_t = Z_t / Z_{t-1} - 1
\end{displaymath}
Using the expression for $Z_{t-1}$
\begin{displaymath}
Z_{t-1} = z_{t-2,n}  \sum_{i=1}^{n} \prod_{j=1}^{i}(1+ x_{t-1,j})
\end{displaymath}
we obtain
\begin{displaymath}
X_t = \frac{\prod_{j=2}^{n}(1+ x_{t-1,j}) \sum_{i=1}^{n} \prod_{j=1}^{i}(1+ x_{t,j})}
{1 + \sum_{i=2}^{n} \prod_{j=2}^{i}(1+ x_{t-1,j})}) - 1
\end{displaymath}

### CGRC method
Define $x$ to be the percentage change in $z$. Thus
\begin{displaymath}
 x_{t,i} = 100 (z_{t,i} - z_{t,i-1}) / z_{t,i-1}
\end{displaymath}
We can also define $z_{t,i}$ in terms of $x$ as follows
\begin{eqnarray*}
z_{t,i} & = & z_{t,i-1}(1 + 0.01 x_{t,i})\\
        & = & z_{t-1,n} \prod_{j=1}^{i}(1+0.01 x_{t,j})
\end{eqnarray*}
Now define $Z_t$ as the level timeseries in time domain $t$ corresponding
to $z$
\begin{displaymath}
Z_t = \sum_{i=1}^{n} z_{t,i}
\end{displaymath}
Then $X$ in any period $t$ can be calculated from
\begin{displaymath}
X_t = 100(Z_t / Z_{t-1} -1)
\end{displaymath}
Further derivations are analogous to the case for the \texttt{cgr} method
described in the previous section.















<!--
The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
-->
