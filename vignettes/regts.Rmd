---
title: "Introduction package regts"
author: "Rob van Harrevelt and Anita van der Roest"
date: '`r Sys.Date()`'
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
linkcolor: blue    
---
<!--
%\VignetteEngine{knitr::rmarkdown}
%\VignetteIndexEntry{Introduction package regts}
-->

```{r echo = FALSE, message = FALSE}
library(regts)
library(zoo)
data <- matrix(c(3,2,4,3,5,2,5,3), ncol = 2)
data1 <- matrix(1:9, ncol = 3)
input <- 1:10

# outputlines start with R>
knitr::opts_chunk$set(collapse = TRUE, comment = "R>")
```

\newpage
# Introduction

Why a new package regts?

When you start looking in R for timeseries you easily find several 
classes and packages, class `ts` from the `stats` package and `zoo` being mentioned most.
The function `ts` creates a regular timeseries object with class `ts`. This can be a univariate or multivariate object. It has a start, an end, a frequency and you can print, plot, extend and update it. But class `ts` can only deal with numeric time stamps. 

<!--   
The zoo package provides infrastructure for regularly and irregularly spaced timeseries. Classes `yearmon` and `yearqtr` from zoo allow for more convenient computation with monthly and quarterly observations, respectively.
-->

We believe that we can add something to the existing structures.
Where packages like `xts` and `zoo` concentrate on daily (or weekly) based data, we aim for timeseries with annual, quarterly and monthly periods, like economic data.  

`Regts` is a package defined for regular timeseries objects with easy features for selecting periods. Another extension is the use of labels, a description of the timeseries. Furthermore a special set of aggregation functions is added.

The `regts` package defines a class `regts` that is an extension to the `ts` class.
Because of this the `regts` class benefits of all the functionality of `ts`.
The period handling is especially for monthly, quarterly and annual timeseries and is much easier than in the `ts` class.

Package `regts` is placed in a library, which must be loaded:
```{r eval = FALSE}
library(regts)
```


# Creation regts

## Single timeseries
A single `regts` timeseries is defined by the function `regts`. A single timeseries is typically created from vector data and is always one-dimensional. The most simpel form is:

```{r echo = 1}
tq <- regts(1:10, start = "2016Q3")
```
with output:
```{r echo = FALSE}
tq
```

The period can also be a year:

```{r echo = 1}
ty <- regts(c(.11, .29, .18, .24), start = "2017")
```
```{r echo = FALSE}
ty
```
Printing a year timeseries looks different from quarterly timeseries output.

The `class` of `tq` and `ty` is `regts`, and because of the inheritance, also `ts`.
```{r}
class(tq)
```
If the input data is longer than you require you can make a selection with the `end` parameter:
```{r eval = TRUE}
ts_data <- regts(input, start = "2016Q1", end = "2016Q4")
```

The character strings that are given for the `start` and `end` parameter are automatically converted to a `regperiod`. See also section [regperiod](#regperiod). 


## Multiple timeseries
Sometimes it is more convenient to combine several timeseries in one multiple timeseries. 
Basic data for a multiple timeseries is a two-dimensional matrix with two or more columns. In fact a multiple `regts` is nothing more than a matrix with some extra facilities.

As we like access to each timeseries usually names are specified,
these names represent the column names of the (multivariate) timeseries.

Labels are the description of these series and can be given optionally (see also section [labels](#labels)):

```{r}
rts1 <- regts(matrix(1:9, ncol = 3), start = "2016Q1", names = c("a", "b", "c"))
rts2 <- regts(matrix(1:8, ncol = 2), start = "2010Q4", names = c("a1", "a2"),
              labels = paste("Timeseries", c("a1", "a2")))
rts1
```
```{r}
class(rts1)
```

Since timeseries rts1 is multiple, classes `mts` (the multiple `ts`) and `matrix` are applicable.

### Column selection and creation

With column selection we get access to each single timeseries or to a subset of the original multiple timeseries:

```{r}
a1_ts <- rts2[ , "a1"]
ac_ts <- rts1[ , c("a", "c")]
```

Or we can create a new column:

```{r echo = 1}
rts1[, "x"] <- 2 * rts1[, "a"]  # creating a new column "x"
rts1
```

### Selecting columns with a regular expression
The `regts` package contains a special function `select_columns` to select columns of an R object with column names. Besides `regts` this can be a `matrix` or a `data.frame`.
The columns with names matching a given regular expression are selected.
A few examples:

```{r}
rts <- regts(matrix(1:8, ncol = 4), start = "2016Q1", names = c("a1", "b1", "a2", "b2"))
select_columns(rts, regex = "a.*")  # all columns with names starting with a
select_columns(rts, regex = ".+1")  # all columns with names ending with 1
```

The syntax of `regular expression` patterns is described in the R Documentation.
<!-- 
`Data` can be a vector, a matrix or inputdata. `Start` and `end` are `regperiods` or types that can be converted to a `regperiod`. 

`Frequency` only has to be specified if no period indicator is known from the `start` or `end` parameter. 


ts_data <- regts(matrix(1:8, ncol = 2), start = "2016Q1", end = "2016Q4",
                 names = c("a", "b"), labels = c("Series_a", "Series_b"))
ts_data
```
-->

## Special one-dimensional case
If a `regts` is created from a matrix with only one dimension (`ncol = 1`), the timeseries is single. So there are two types of single timeseries: the one that is based on a vector and the one that is based on a one-column matrix: 

```{r}
ts      <- regts(1:4, start = "2016Q1")
ts_1col <- regts(matrix(1:4, ncol = 1), start = "2016Q1", names = "a")
```
They have identical output:
```{r, echo = FALSE }
ts
```
```{r, echo = FALSE }
ts_1col
```

Difference between the 'vector' version and the 'matrix-1-column' version is that the latter can have a column name, as you can see in the previous example. Single 'vector' timeseries never have a column name. In RStudio you can see the difference (the column name) with the `View` function.

A single 'matrix-1-column' timeseries arises too when a single column is selected from a multiple timeseries with the argument `drop = FALSE`. In this case the column name is preserved. If this argument is omitted (or `drop = TRUE` is used) a single 'vector' timeseries is created. A possible column name disapppears in this case. An example:  

```{r results = "hide"}
rts <- regts(matrix(1:8, ncol = 2), start = "2016Q1", names = c("a", "b"))

rts[ ,1, drop = FALSE] # result is a one-dimensional matrix with column name "a"
rts[ ,2]               # result is a vector, column name "b" is lost
```



<!--
A multivariate timeseries can be built in three ways:

1. created with a matrix as data
2. with the `as.regts` function
3. constructed from several (univariate and multivariate) timeseries

For the second item we refer to section [dataframe](#dataframe). The merging
of several (univariate and multivariate) timeseries is discussed in the 
[cbind](#cbind) section.
-->

# Period selection
Regts is specially designed for the selection of periods. Where for a `ts` timeseries you have to use the `window` function, with a `regts` you deal directly with the (reg)periods. Period selection is a form of subsetting. It can be applied anywhere on all `regts` objects. 

To select a period from a `regts` there are several possibilities. You can use a characterstring with a period specification
^[When applying character selection you can use both symbols: ' or ".]
or column numbers. Some examples:

```{r}
rts <- regts(1:8, start = "2010Q1", end = "2011Q4")

# selection in the source with period specification or column numbers
rts1 <- rts["2010Q1"]
rts2 <- rts["2010Q2/2011Q3"]
rts3 <- rts["/2011Q2"]
rts4 <- rts[3]
```

Meaning of the period specifications:

```{r eval = FALSE}
"2010Q1"            single first quarter of 2011
"2010Q2/2011Q3"     period starting in 2nd quarter of 2010 and ending in 
                    3rd quarter of 2011
"/2011Q2"           period starting in first period timeseries and 
                    ending in 2nd quarter of 2011
```

If a selection is specified with a period indicator outside the defined range, the timeseries is filled with NA values for that area:

```{r}
rts["/2012Q2"]
rts["2009Q3"] 
```

Some more examples with period selection on the lefthandside of an assignment, in the target timeseries. The object must exist before applying selection.

```{r}
rts1 <- regts(1:8, start = "2010Q1", end = "2011Q4")
rts1["2011Q2"] <- 2
rts1["/2011Q1"] <- 99
```


```{r eval = FALSE, echo=FALSE}
# gives warning because rts5 doesn't exist
rts5["2011Q3"] <- 2 * rts1["2011Q3"]  
```

Period extensions (before and/or after) are dealt with automatically:
```{r}
rts1
rts1["2009Q1/2009Q2"] <- rts1["2010Q3/2010Q4"]
rts1
```
The missing quarters (2009Q3 and 2009Q4) are filled in with NA values.

## Period selection for multivariate regts

Selecting a period for a multivariate regts is quite similar. You can select one or more periods, or a combination of period(s) and columns:

```{r}
rts <- regts(matrix(1:12, ncol = 3), start = "2011Q1", names = c("a", "b", "c"))

rts["2011Q2", ]

rts["2011Q2"]     # the , is not necessary

rts["2011Q1/2012Q2", "c"]

rts["2011Q4/", c("a", "b")]
```

Selection in the target timeseries:

```{r echo = 1:2}
rts["2012Q1", ] <- 99         # period extending 
rts["2011", "x"] <- 1         # update all quarters in 2011 in column "x"
rts
```

All not defined elements become Na.

When the same period selection recurs the `regts` package offers a nice solution: the `regperiod`. It will be described in the next section.


# Regperiod and regperiod_range{#regperiod}

When you repeatedly use the same period, it is handy to define a variable containing this period. Besides periods in characterstrings it is also possible to use `regperiod` or `regperiod_range` variables as means of selection.  

A `regperiod` variable can be created with the `regperiod` function. 

```{r}
prd1 <- regperiod("2016Q4")
prd2 <- regperiod("2015-2", frequency = 2)
```

In the second example the `frequency` has to be specified. "2015-2" is not decisive. The "2" can also be a quarter or a month indicator.

The result `regperiod` can become the input for the `start` and `end` parameters of the `regts` function.

```{r eval = TRUE}
first <- regperiod("2015Q1")
ts    <- regts(1:10, start = first)
```

Or you can use it as a way to select or update a part of a timeseries:
```{r}
var <- rts1[prd1] 
rts1[prd1] <- 3
```

And with  operators `+` and `-` simple arithmetic operations can be performed:

```{r}
prd3 <- prd2 + 1
prd3
prd2 - 5
```

A `regperiod` seems to be nothing more than a character string. With the `str` function we can show the real content of object prd1 :

```{r}
str(prd1)
```

The internal representation of period `2016Q4` is `2016 * 4 + 3 = 8067`.

## Regperiod_range

Obviously there is also a `regperiod_range`, an object that represents an interval of `regperiod`. Such a range can be created in the following ways:

```{r}
range1 <- regperiod_range("2014Q4", "2017Q4")
range2 <- regperiod_range("2017Q1", NULL)   # No upperbound

p1     <- regperiod("2015Q1")
range3 <- regperiod_range(p1, p1+4)

range4 <- range3 + 1
```

The results look like:

```{r echo = FALSE}
range1 
range2 
range3
range4
```

As you can see the lower or upper bound of the range may also be undetermined.

A `regperiod_range` has the same selecting and updating possibilities as  `regperiod`:

```{r}
range_2011 <- regperiod_range("2011Q1", "2011Q4")
var2011 <- rts[range_2011]
rts[range_2011, c("a", "b")]

smpl <- regperiod_range("2011Q1", "2012Q4")
rts[smpl, 'xx'] <- 2          # creating a new column "xx" for period smpl
rts
```
Notice that because timeseries 'xx' is created with an extended period, all timeseries in (multiple regts) variable rts are extended.

A range can also be constructed from an R object by using the `as.regperiod_range` function, for instance to convert a character string:

```{r}
as.regperiod_range("2016Q1/2016Q4")
as.regperiod_range("/2016Q1")       # No lowerbound 
```

The length of the range may be obtained by using the `lensub` function:

```{r results = "hide"}
lensub(range1)
```
Functions `start_period` and `end_period` are used to select the first and last period in a `regperiod_range`:

```{r}
ts <- regts(data, start = start_period(range1), end = end_period(range1))
```

# Labels {#labels}
`Regts` timeseries are equipped with a label, a way to document each specific timeseries. Labels can be defined when creating the series and retrieved with the `ts_labels` function. 

```{r}
t1 <- regts(1:6, start = "2016Q1", labels = 'Test')
t2 <- regts(data, start = "2017Q1", names = c("child", "adult"),
            labels = c("Age 0-17", "Age 18-"))
```

Labels are not shown automatically when printing the timeseries:

```{r echo = FALSE}
t1
```

Use the `ts_labels` function or `View` function in RStudio to view them:

```{r}
ts_labels(t1)
```

Labels can also be determined in advance (or read from a file):

```{r}
column_names <- c("a", "b", "c")
labels <- paste("Timeseries", column_names)
rts    <- regts(data1, start = "2017Q1", names = column_names, labels = labels)
ts_labels(rts)
```

In combination with the `<-` operator, the `ts_labels` command can be used to set labels to or remove labels from an existing `regts`:

```{r}
tx <- regts(1:10, start = "2017Q1")
ts_labels(tx) <- "Trans X"
ts_labels(t2) <- NULL # remove all labels from multivariate timeseries t2
```

For updating one or more timeseries labels in a multivariate `regts` object, the function `update_ts_labels` is provided:

```{r eval = TRUE}
rts <- update_ts_labels(rts, c(b = "Updated content b"))
```
```{r echo = FALSE}
ts_labels(rts)
```

Labels are preserved in most timeseries functions.


# Data frame {#dataframe}
The data frame type in R is widely used and extensively documented elsewhere, so here we will only describe the use related to `regts` objects.

It is possible to use a (part of a) data frame as input data for a `regts`

```{r}
df  <- data.frame(a = 1:3, b = 4:6, c = 7:9)

ts1 <- regts(df, start = "2017Q1")       # create a multivariate regts
ts2 <- regts(df[, 2], start = "2017Q2")  # create a univariate regts
```
with results:
```{r eval = FALSE}
df                  ts1                   ts2
  a b c                     a b c           
1 1 4 7             2017 Q1 1 4 7              Qtr2 Qtr3 Qtr4
2 2 5 8             2017 Q2 2 5 8         2017    4    5    6
3 3 6 9             2017 Q3 3 6 9
```

The function `regts` uses the `data.matrix` function in the `base` package to convert a data frame to a numeric matrix. Default the df colnames are used for the timeseries names. Names and/or labels can also be given:

```{r}
ts <- regts(df, start = "2017Q1", names = c("v1", "v2", "v3"),
            labels = c("label1", "label2", "label3"))
```

## Converting data frame <-> regts
There is also  the possibility of conversion. Two conversion functions are used to easily convert a `data frame` to a `regts` and vice versa: `as.regts` and `as.data.frame`, both S3 generics. 

When converting a `data.frame` to a `regts` the period must be set. 
That is why the function `as.regts` has a `time_column` parameter. You can specify the column name(s) or number(s) of the data frame in which the period is stored. 
If the period is contained in the row names of the data frame specify 0 or
omit the parameter, since this is the default:

```{r}
# data frame with period in row names
df <- data.frame(a = 1:3)
rownames(df) <- c("2015Q3", "2015Q4", "2016Q1")
ts <- as.regts(df)

# data frame with period in column
df2 <- data.frame(periods = c("2015Q3", "2015Q4", "2016Q1"),  a = 1:3)
ts <- as.regts(df2, time_column = "periods")

```

When converting non standard periods in the data frame (no `regperiod` like objects), use the `fun` parameter, if necessary with extra arguments:

```{r}
rownames(df) <- c("2015 3", "2015 4", "2016 1")
ts <- as.regts(df, fun = as.regperiod, frequency = 4)
```

The `as.data.frame` function is extended for `regts` types:
```{r}
ts  <- regts(matrix(1:6, ncol = 2), start = "2017Q1", names = c("a","b"))
df  <- as.data.frame(ts)
```
```{r eval = FALSE}
ts                       df                   
        a b                      a b            
2017 Q1 1 4              2017 Q1 1 4               
2017 Q2 2 5              2017 Q2 2 5          
2017 Q3 3 6              2017 Q3 3 6 
```
The results look similar. The timeseries names become the data frame column names. The periods show up in the row names.

When you want to read/write timeseries data from/to a file it is best to use the `data.frame` class as a means to do so.

## Read data frame from file

 There are several ways to read a data frame from a file, like 

* `read.csv` and `fread` for a `csv-file`  
* `read.xlsx` and a combination of `loadworkbook` and `readWorksheet` for a `xls-file`.
* `load("input.Rdata")` 

After reading, convert the data frame with the `as.regts` function:

```{r, echo = 1:2}
df <- read.csv("test.csv", stringsAsFactors = FALSE)

df
```
```{r, echo = 1:2}
series <- as.regts(df, time_column = 1)

series
```

Use `stringsAsFactors = FALSE` to prevent that character data (such as variablenames) is converted to factors.

Sometimes the data frame obtained is transposed, e.g. periods in the first row and column names in the first column. For creating a 'normal' data frame use the `transpose_df` function:

```{r, echo = -3}
dft <- read.csv("transpose.csv", check.names = FALSE)

dft
```
```{r, echo = 1:2}
df <- transpose_df(dft, colname_column = 1)

df
```

When reading the file no check is performed on the names, since they are periods, and therefore no valid names. Valid names should start with [a-z].

With the `colname_column` parameter it is possible to give the name or index of the column that will be used as column names. By default the `row names` of the original data frame are used. In the same way labels can be retrieved with the `label_column` parameter. There is no default option for labels.

```{r eval = FALSE, echo = FALSE}
# read a CSV-file
simple_df <- read.csv(file = "simple.csv", head = TRUE, sep = ",")
input_df  <- fread("input/input.csv",  data.table = FALSE)

# or an XLS-file
filename <- "input/test1.xlsx"
df1 <- read_excel(filename, sheet = 1)               # readxl package
               
wk <- loadWorkbook("mydata.xls")                     # XLConnect package 
df2 <- readWorksheet(wk, sheet="Sheet1")

df3 <- read.xlsx(filename, sheetIndex = 1, check.names = FALSE, 
                 check.rows = FALSE, row.names = 1)  # xlsx package 
```

## Write timeseries via data frame 
When `regts` timeseries data have to be stored on file or dataset, first convert the data using the `as.data.frame` function. The period and names of the `regts` become automatically the `rownames` and `colnames` of the `data.frame`.
Then use one of the available methods to save a data frame:

```{r}
df <- as.data.frame(rts)

write.csv(df, "result.csv")
save(df, file = "output.Rdata")
```


```{r eval = FALSE, echo = FALSE}
df <- as.dataframe(regts)
filename <- "output/result.xls"
write.xlsx(df, filename, sheetName="Sheet1",   # xlsx package
           col.names=TRUE, row.names=TRUE)
           
wb <- createWorkbook(type="xlsx")              # r2excel package
sheet <- createSheet(wb, sheetName = "example1")
xlsx.addTable(wb, sheet, head(iris), startCol=2)
saveWorkbook(wb, filename) 
```

# Operators and functions for regts
Since the `regts` class is an extension of the `ts` class all functionality from this class is available.
All arithmetic, logical, relational and subsetting operators applicable for a `ts` variable can be used for a `regts` timeseries. Some examples:

```{r}
tx <- regts(1:10, start = "2017Q1")

# operators
ty    <- 2*tx + 1
tpyth <- tx**2 + ts**2
tlog  <- tx > ty
number <- tx["2017Q2"]
```
When a dyadic arithmetic operator (`+, -, *, /`) is used on two or more timeseries, the intersection of the periods is taken:

```{r}
tx <- regts(1:6, start = "2016Q1")
ty <- regts(1:6, start = "2017Q1")
tx + ty
```

You can use all functions applicable to a `ts` class timeseries:
```{r, eval = 1,2}

tsin <- sin(tx)
tlag <- lag(tx)
diff(tx)
plot(tx)
```



# Special functions

## Binding timeseries
As we have seen all functions that are available for `ts` are also available for `regts`. The `cbind` function (an S3 generic function) is one of them: it binds two or more objects with a common frequency. With the `cbind` function it is easy to combine several `univariate regts` to a `multivariate regts` or a combination of univariate and multivariate regts to a new multivariate regts. 

Yet the extension for `regts` has special features: arguments `union` and `suffixes`. 

The argument `union` effects the period range. With `union = TRUE` the union of the period ranges of the joined objects is taken, otherwise it is the `intersection`. An example:

```{r}
rt1 <- regts(1:4, start = "2016Q1")
rt2 <- regts(1:4, start = "2016Q2")

cbind(rt1, rt2, union = TRUE)

cbind(rt1, rt2, union = FALSE)
```
For `union = TRUE` the result is padded with NA's if needed.

```{r echo = FALSE, results = "hide"}
data <- matrix(1:8, ncol = 2)
rt1 <- regts(data, start = "2016", names = c("a", "b"))
rt2 <- regts(data, start = "2016", names = c("d", "c"))
t1  <- ts(data, start = c(2016), names = c("a", "b"))
t2  <- ts(data, start = c(2016), names = c("d", "c"))

cbind(rt1,rt2)
ts.union(t1, t2)
cbind(t1,t2)

```

The `suffixes` argument is obligatory if the joined objects have overlapping column names:

```{r}
rt1 <- regts(data1, start = "2016Q1", names = c("b", "a", "c"))
rt2 <- regts(data, start = "2016Q1", names = c("d", "b"))

cbind(rt1, rt2, suffixes = c("_1","_2"))
```

The implementation of `cbind.regts` is also different from function `cbind.ts` (which is an alias for `ts.union`) because of the fact that available column names are always preserved!

# Multiple or chain calculations
Suppose there are a number of univariate timeseries, some of them dependent or in a chain of calculations, that you want to combine in one result. This can be done in the following way:

```{r}
a <- regts(1:4, start = "2010Q2")
b <- lag(a, -1)
c <- b + 1
d <- b / c
rts <- cbind(a, b, c, d)
rts
```

When the basic timeseries is multivariate this example turns into more inconvenient code: 

```{r}
xts <- regts(data, start = "2010Q2", names = c("a", "x"))
xts["2010Q3/2011Q2", "b"] <- lag( xts[, "a"], -1)
xts[, "c"] <- xts[, "b"] + 1
xts[, "d"] <- xts[, "b"] / xts[, "c"]
xts
```
When creating timeseries `b` you also have to define the lagged period. Otherwise the `xts` period is used. 

In this case another method can be preferable: a combination of the `as.list`  and the `within` function. 

```{r}
xts <- regts(data, start = "2010Q2", names = c("a", "x"))
list <- as.list(xts)
list2 <- within(list, {
    b <- lag(a, -1) 
    c <- b + 1
    d <- b / c
})
```

A list can't be converted directly to a `regts` with the `as.regts` function. So we use a combination of functions `cbind` and `do.call` ^[Notice the sequence of the result: the elements are added in reversed order!]:

```{r}
rts2 <- do.call(cbind, list2)
rts2 
```


The elements in the list are all of type `regts`, so the result is a `multivariate regts`. 

If another numeric or logical type is included it is also converted to a regts:

```{r}
# extend list2
list3 <- within(list2, {
    e <- 0
    f <- TRUE
})
rts3 <- do.call(cbind, list3)
rts3
```

The elements `e` and `f` are blown up for the whole period and the value `TRUE` is transformed to `numeric`. ^[You could also add a variable g <- "a", the result variable will remain a `regts` but it is no longer possible to perform calculations!]



# Differences between multivariate timeseries
The function `tsdif` is specially designed to compare two multivariate timeseries objects with the same frequency. Absolute and relative differences between the common columns can be calculated with a tolerance factor:

```{r}
diflist <- tsdif(rt1, rt2, tol = 1e-3)
``` 
By default the absolute differences are calculated.

The result is a list with components e.g. the tolerance parameter (`tol`),  the actual result which is TRUE or FALSE (`equal`) and the names of the common columns with differences larger than `tol` (`difnames`).

The `equal` component, in this case `diflist$equal`, is only TRUE if the two objects have the same column names and if all the differences are smaller than or equal to the tolerance factor.

# Aggregate functions
Normal use of the aggregate function works fine for both `ts` and `regts`:
```{r results = "hide"}
regt1 <- regts(1:10, start = "2016Q1")
t1    <- ts(1:10, start = c(2016,1), frequency = 4)

aggregate(regt1, FUN = sum, nfrequency = 1)
aggregate(t1,    FUN = sum, nfrequency = 1)
```

The compressed results are: 

```{r eval = FALSE}
regt1  Time Series: Start = 2016  End = 2017  Frequency = 1  [1] 10 26
t1     Time Series: Start = 2016  End = 2017  Frequency = 1  [1] 10 26
```

A problem arises when a quarterly timeseries doesn't start in the first quarter:
```{r results = "hide"}
regt2 <- regts(2:10, start = "2016Q2")
t2    <- ts(2:10, start = c(2016,2), frequency = 4)
aggregate(regt2, FUN = sum, nfrequency = 1)
aggregate(t2,    FUN = sum, nfrequency = 1)
```

has results:

```{r eval = FALSE}
regt2  Time Series: Start = 2017     End = 2017     Frequency = 1  [1] 26
t2     Time Series: Start = 2016.25  End = 2017.25  Frequency = 1  [1] 14 30
```
Because of the shifted period, it is obvious something is wrong,
but the results are peculiar. For a `regts` timeseries this (known) bug is mended and incomplete years are ignored.

## Special aggregation
For timeseries which contain for instance growth rates (absolute or relative), aggregation to a lower frequency takes special steps. A simple averaging of n high frequency observations will not return the correct answer.

For this case special aggregation algorithms are developed, the so called "cgrx"-methods. All methods convert input timeseries with high frequency to low frequency outputseries. The type of method depends on the input:

* `cgr` : input is a first difference scaled to the output frequency (an annualised quarterly first difference), output is a first difference
* `cgrs`: input and output are first differences
* `cgru`: input and output are relative changes
* `cgrc`: input and output are percentage changes

The `cgr` and `cgrs` methods assume that the input timeseries is a first difference of length 1 in the inputfrequency and calculate a first difference of length 1 in the outputfrequency. It can also be used for relative changes that
are small but this will not give exact results for very large numbers. 

The `cgru` and `cgrc` methods assume that the input timeseries is a one-period relative or percentage change and calculate the exact relative or percentage change for the output timeseries.

Some examples:
```{r eval = FALSE}
aggregate_gr(xdif, method = "cgr", nfrequency = 1)
aggregate_gr(xdif, method = "cgrs")
```

The next sections describe the transformations required for these four
frequency conversion methods.

### CGR method
Define $x$ to be the first difference  of $z$ scaled to the output frequency.
Thus
\begin{displaymath}
 x_{t,i} = n ( z_{t,i} - z_{t,i-1} )
\end{displaymath}
We can also define $z_{t,i}$ in terms of $x$ as follows
\begin{eqnarray*}
z_{t,i} & = & z_{t,i-1} + x_{t,i}/n\\
        & = & z_{t-1,n} + \sum_{j=1}^{i} x_{t,j}/n
\end{eqnarray*}
Now define $Z_t$ as the level timeseries in time domain $t$ corresponding
to $z$
\begin{eqnarray*}
Z_t &=& \sum_{i=1}^{n} z_{t,i}\\
    &=& \sum_{i=1}^{n} z_{t-1,n} + \sum_{i=1}^{n} \sum_{j=1}^{i} x_{t,j}/n\\
    &=& \sum_{i=1}^{n} z_{t-2,n} + \sum_{i=1}^{n} \sum_{j=1}^{n} x_{t-1,j}/n + \sum_{i=1}^{n} \sum_{j=1}^{i} x_{t,j}/n
\end{eqnarray*}
Then $X$ in any period $t$ can be calculated from
\begin{displaymath}
X_t = Z_t - Z_{t-1}
\end{displaymath}
Since $Z_{t-1}$ can be written as
\begin{displaymath}
Z_{t-1} = \sum_{i=1}^{n} z_{t-2,n} + \sum_{i=1}^{n} \sum_{j=1}^{i} x_{t-1,j}/n\\
\end{displaymath}
it is easy to show that $X_t$ does not depend on $z_{t-2,n}$.
In any practical algorithm $z_{t-2,n}$ can be set to 0.

A compact equation for $X_t$ can be derived by substituting the equations for
$Z_t$ and $Z_{t-1}$ into the definition of $X_t$
\begin{displaymath}
X_t = \sum_{i=1}^n
        \left(
          \sum_{j=i+1}^n x_{t-1,j} + \sum_{j=1}^n x_{t-1,j+n}
        \right) / n
\end{displaymath}
where $x_{t,j} = x_{t-1,j+n}$.
By changing indices in the two inner summations this can be simplified considerably.
Set $j=i+k$ in the first inner sum and $j=i+k-n$ in the second and after some
rearrangement we get
\begin{displaymath}
X_t = \sum_{i=1}^n \sum_{k=1}^n x_{t-1,i+k} / n
\end{displaymath}


### CGRS method
Define $x$ to be the first difference  of $z$. Thus
\begin{displaymath}
 x_{t,i} = z_{t,i} - z_{t,i-1}
\end{displaymath}
We can also define $z_{t,i}$ in terms of $x$ as follows
\begin{eqnarray*}
z_{t,i} & = & z_{t,i-1} + x_{t,i}\\
        & = & z_{t-1,n} + \sum_{j=1}^{i} x_{t,j}
\end{eqnarray*}
Further derivations are analogous to the case for the \texttt{cgr} method
described in the previous section.

### CGRU method
Define $x$ to be the relative change in $z$. Thus
\begin{displaymath}
 x_{t,i} = (z_{t,i} - z_{t,i-1}) / z_{t,i-1}
\end{displaymath}
We can also define $z_{t,i}$ in terms of $x$ as follows
\begin{eqnarray*}
z_{t,i} & = & z_{t,i-1}(1 + x_{t,i})\\
        & = & z_{t-1,n}  \prod_{j=1}^{i}(1+ x_{t,j})\\
        & = & z_{t-2,n} \prod_{j=1}^{n}(1+ x_{t-1,j}) \prod_{j=1}^{i}(1+ x_{t,j})
\end{eqnarray*}
Now define $Z_t$ as the level timeseries in time domain $t$ corresponding
to $z$
\begin{eqnarray*}
Z_t &=& \sum_{i=1}^{n} z_{t,i}\\
    &=&  z_{t-1,n} \sum_{i=1}^{n} \prod_{j=1}^{i}(1+ x_{t,j})\\
    &=&  z_{t-2,n} \prod_{j=1}^{n}(1+ x_{t-1,j}) \sum_{i=1}^{n} \prod_{j=1}^{i}(1+ x_{t,j})
\end{eqnarray*}
Then $X$ in any period $t$ can be calculated from
\begin{displaymath}
X_t = Z_t / Z_{t-1} - 1
\end{displaymath}
Using the expression for $Z_{t-1}$
\begin{displaymath}
Z_{t-1} = z_{t-2,n}  \sum_{i=1}^{n} \prod_{j=1}^{i}(1+ x_{t-1,j})
\end{displaymath}
we obtain
\begin{displaymath}
X_t = \frac{\prod_{j=2}^{n}(1+ x_{t-1,j}) \sum_{i=1}^{n} \prod_{j=1}^{i}(1+ x_{t,j})}
{1 + \sum_{i=2}^{n} \prod_{j=2}^{i}(1+ x_{t-1,j})}) - 1
\end{displaymath}

### CGRC method
Define $x$ to be the percentage change in $z$. Thus
\begin{displaymath}
 x_{t,i} = 100 (z_{t,i} - z_{t,i-1}) / z_{t,i-1}
\end{displaymath}
We can also define $z_{t,i}$ in terms of $x$ as follows
\begin{eqnarray*}
z_{t,i} & = & z_{t,i-1}(1 + 0.01 x_{t,i})\\
        & = & z_{t-1,n} \prod_{j=1}^{i}(1+0.01 x_{t,j})
\end{eqnarray*}
Now define $Z_t$ as the level timeseries in time domain $t$ corresponding
to $z$
\begin{displaymath}
Z_t = \sum_{i=1}^{n} z_{t,i}
\end{displaymath}
Then $X$ in any period $t$ can be calculated from
\begin{displaymath}
X_t = 100(Z_t / Z_{t-1} -1)
\end{displaymath}
Further derivations are analogous to the case for the \texttt{cgr} method
described in the previous section.















<!--
The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

## Figures

The figure sizes have been customised so that you can easily put two images side-by-side. 

```{r, fig.show='hold'}
plot(1:10)
plot(10:1)
```

You can enable figure captions by `fig_caption: yes` in YAML:

    output:
      rmarkdown::html_vignette:
        fig_caption: yes

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## More Examples

You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
-->
